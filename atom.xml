<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhyat Blog</title>
  
  <subtitle>学而思之</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhyat.cn/"/>
  <updated>2019-09-02T17:38:32.110Z</updated>
  <id>http://blog.zhyat.cn/</id>
  
  <author>
    <name>zhyat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="http://blog.zhyat.cn/2019/09/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zhyat.cn/2019/09/02/设计模式之单例模式/</id>
    <published>2019-09-02T09:16:35.332Z</published>
    <updated>2019-09-02T17:38:32.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>定义：保证一个类仅有一个实例,并提供一个访问它的全局访问点。<br>使用场景：全局缓存、Windows对象、登录浮窗等<br>关键：用一个变量来标志是否已经为某个类创建对象，没有则创建，有则返回这个对象</p><h2 id="标准单例模式"><a href="#标准单例模式" class="headerlink" title="标准单例模式"></a>标准单例模式</h2><p>代码实现：<br><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标准单例模式</span></span><br><span class="line"><span class="comment"> * 缺点是使用者必须知道这是个单例类，本来可以直接new xxx，现在变成了xxx.getInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.instance = <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Singleton.prototype.getInstance = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.instance!==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="透明单例模式"><a href="#透明单例模式" class="headerlink" title="透明单例模式"></a>透明单例模式</h2><p><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用闭包和IIFE实现了透明单例模式</span></span><br><span class="line"><span class="comment"> * 但违反了单一职责原则</span></span><br><span class="line"><span class="comment"> * 缺点是，当不再需要单例时，需要改写构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance</span><br><span class="line">  <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.html = html</span><br><span class="line">    <span class="keyword">this</span>.init() <span class="comment">// 执行init方法</span></span><br><span class="line">    <span class="keyword">return</span> (instance = <span class="keyword">this</span>) <span class="comment">// 保证只有一个一个对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    div.innerHTML = <span class="keyword">this</span>.html</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> CreateDiv</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><h2 id="用代理实现的单例"><a href="#用代理实现的单例" class="headerlink" title="用代理实现的单例"></a>用代理实现的单例</h2><p><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理实现单例</span></span><br><span class="line"><span class="comment"> * 将负责管理单例的逻辑移到proxySingletonCreate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> CreateSpan = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.html = html</span><br><span class="line">  <span class="keyword">this</span>.init()</span><br><span class="line">&#125;</span><br><span class="line">CreateSpan.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>)</span><br><span class="line">  span.innerHTML = <span class="keyword">this</span>.html</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(span)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxySingletonCreate = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) [(instance = <span class="keyword">new</span> CreateSpan(<span class="string">'test'</span>))]</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><h2 id="创建单例的通用方法"><a href="#创建单例的通用方法" class="headerlink" title="创建单例的通用方法"></a>创建单例的通用方法</h2><p>由上可以看出，创建单例的核心即为使用一个变量表示这个对象是否被创建，即：<br><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance</span><br><span class="line"><span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">   instance = xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体代码实现即为：<br><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建单例的抽象方法</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; fn </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;定义：保证一个类仅有一个实例,并提供一个访问它的全局访问点。&lt;br&gt;使用场景：全局缓存、Windows对象、登录浮窗等&lt;br
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
      <category term="设计模式/Design Pattern" scheme="http://blog.zhyat.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计稿中字体对应的字重</title>
    <link href="http://blog.zhyat.cn/2019/07/10/%E5%AD%97%E4%BD%93%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E9%87%8D/"/>
    <id>http://blog.zhyat.cn/2019/07/10/字体对应的字重/</id>
    <published>2019-07-09T19:21:55.464Z</published>
    <updated>2019-09-02T17:30:24.380Z</updated>
    
    <content type="html"><![CDATA[<p>设计师给的标注文件经常会出现一个情况，字重总是通过直接设置具体的字体来指定字重，实际上在font-family那一行Medium指的是字重。<br><img src="/2019/07/10/字体对应的字重/exp1.png" title="例子"></p><p>其对应关系大致符合：<br>100 - Thin<br>200 - Extra Light (Ultra Light)<br>300 - Light<br>400 - Regular (Normal、Book、Roman)<br>500 - Medium<br>600 - Semi Bold (Demi Bold)<br>700 - Bold<br>800 - Extra Bold (Ultra Bold)<br>900 - Black (Heavy)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计师给的标注文件经常会出现一个情况，字重总是通过直接设置具体的字体来指定字重，实际上在font-family那一行Medium指的是字重。&lt;br&gt;&lt;img src=&quot;/2019/07/10/字体对应的字重/exp1.png&quot; title=&quot;例子&quot;&gt;&lt;/p&gt;
&lt;p&gt;其对应关
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://blog.zhyat.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES6 之 Symbol</title>
    <link href="http://blog.zhyat.cn/2019/06/02/ES6-Symbol/"/>
    <id>http://blog.zhyat.cn/2019/06/02/ES6-Symbol/</id>
    <published>2019-06-01T22:39:12.266Z</published>
    <updated>2019-06-02T07:16:08.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Symbol 的用法其实很简单，就是创建一个独一无二的值。<br>举个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>() == <span class="built_in">Symbol</span>() <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><img src="/2019/06/02/ES6-Symbol/Symbol_not_equal.png" title="Symbol()之间不相等"><p>需要注意的是，不能使用 <code>new</code> 创建 <code>Symbol</code> ，因为 <code>Symbol</code> 是一个基本类型。</p><p>通常在使用 <code>Symbol</code> 的时候，会在其中加入标识符，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// Symbol(foo)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>) == <span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>).toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>).toString() === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>).toString() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><img src="/2019/06/02/ES6-Symbol/Symbol_exp1.png" title="Symbol()的一些情况"><p><code>Symbol</code> 有 <code>toString()</code> 方法</p><h2 id="主要使用场景"><a href="#主要使用场景" class="headerlink" title="主要使用场景"></a>主要使用场景</h2><h3 id="作为对象的属性名"><a href="#作为对象的属性名" class="headerlink" title="作为对象的属性名"></a>作为对象的属性名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line">o[mySymbol] = <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><p>需要注意的是，使用 <code>Symbol</code> 作为属性名时，要用 <code>[]</code> 的方式访问，因为点符号后面跟的只能时字符串。</p><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>保证这些常量不相等<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = &#123;&#125;</span><br><span class="line">log.levels = &#123;</span><br><span class="line">  DEBUG: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),</span><br><span class="line">  INFO: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),</span><br><span class="line">  WARN: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.DEBUG, <span class="string">'debug message'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.INFO, <span class="string">'info message'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="保证-Switch-按照设计使用"><a href="#保证-Switch-按照设计使用" class="headerlink" title="保证 Switch 按照设计使用"></a>保证 Switch 按照设计使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> COLOR_RED    = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> COLOR_GREEN  = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> COLOR_RED:</span><br><span class="line">      <span class="keyword">return</span> COLOR_GREEN;</span><br><span class="line">    <span class="keyword">case</span> COLOR_GREEN:</span><br><span class="line">      <span class="keyword">return</span> COLOR_RED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Symbol 还有一些其他方法，请参阅读<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">MDN Web Docs</a></p><p>不过需要特别注意的是，Symbol 定义的属性名，在使用 <code>for...in</code> 、<code>for...of</code> 等需要有迭代器的方法时不会出现，要获得一个对象所有的<code>Symbol</code> 属性名可以使用 <code>Object.getOwnPropertySymbols()</code> 方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;Symbol 的用法其实很简单，就是创建一个独一无二的值。&lt;br&gt;举个例子：&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhyat.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中判断 this 指向的一些方法</title>
    <link href="http://blog.zhyat.cn/2019/05/27/JavaScript%E4%B8%AD%E5%88%A4%E6%96%ADthis%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.zhyat.cn/2019/05/27/JavaScript中判断this指向的一些方法/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2019-06-02T07:16:08.004Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的 this 可能是 JS 这门语言中最难的一个关键字，想要去理解 this 运作的原理对 JS 需要一定的使用经验。本文并不深究 this 为什么指向某个地方，本文是一篇方法论的文章，只说明怎么样判断 this 的指向。</p><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><ol><li>this 指向自身 ❌</li><li>this 指向函数的作用域 ❌</li></ol><h3 id="正确的说法"><a href="#正确的说法" class="headerlink" title="正确的说法"></a>正确的说法</h3><blockquote><p>this 实际上是发生在函数调用时候的绑定，它指向什么完全取决于函数在哪里调用</p></blockquote><p>看得明明白白，好像自己真的懂了是不是？呵呵，不可能的。</p><h3 id="绑定的几条规则"><a href="#绑定的几条规则" class="headerlink" title="绑定的几条规则"></a>绑定的几条规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>独立函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>f()没有加任何的修饰的函数引用，所以此函数不可能使用其他规则，进而 this 此时指向的就是全局对象。不过需要注意的是，在严格模式中，this 是不可以绑定到全局对象上的。</p><p>这条规则就是，别的规则都不生效，那就是这条规则。</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>当调用位置有上下文对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a:<span class="number">1</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.foo() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但是这条规则有几个需要注意的场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a:<span class="number">1</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fCopy = o.foo <span class="comment">// 别名</span></span><br><span class="line">fCopy() <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure><p>为什么会出现这种情况呢？因为实际上<code>fCopy</code> 是 <code>foo</code> 的引用, 是一个没有修饰符，即没有上下文对象的函数调用。</p><h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><p>使用 <code>call</code> 和 <code>apply()</code> 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">f.call(o)</span><br></pre></td></tr></table></figure></p><p>这个很明显了，就是手动的明确的，将f的this指向绑定到o上。</p><h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">f.a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>js 的 new 实际上不是面向对象如java那种创建一个对象的实例，它是基于原型关系的。</p><p>先创建了一个对象，然后连接到到原型上。关于这一块，可以参考 JavaScript 实现复用那篇文章。</p><h3 id="优先级别"><a href="#优先级别" class="headerlink" title="优先级别"></a>优先级别</h3><p>new &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2019/05/27/JavaScript中判断this指向的一些方法/this_flow.png" title="this指向的流程图">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript 中的 this 可能是 JS 这门语言中最难的一个关键字，想要去理解 this 运作的原理对 JS 需要一定的使用经验。本文并不深究 this 为什么指向某个地方，本文是一篇方法论的文章，只说明怎么样判断 this 的指向。&lt;/p&gt;
&lt;h3 id=&quot;误
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhyat.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>每日一道大厂题-HTTPS握手</title>
    <link href="http://blog.zhyat.cn/2019/03/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%81%93%E5%A4%A7%E5%8E%82%E9%A2%98-HTTPS%E6%8F%A1%E6%89%8B/"/>
    <id>http://blog.zhyat.cn/2019/03/29/每日一道大厂题-HTTPS握手/</id>
    <published>2019-03-28T20:20:20.921Z</published>
    <updated>2019-06-02T07:16:08.003Z</updated>
    
    <content type="html"><![CDATA[<p><strong>来自<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question" target="_blank" rel="noopener">Daily-Interview-Question</a></strong></p><p>Q：介绍 HTTPS 握手过程</p><ol><li>Client Hello</li><li>Server Hello</li><li>Certificate</li><li>Server Hello Done</li><li>Client Key Exchange</li><li>Change Cipher Spec</li><li>Finished</li><li>Change Cipher Spec</li><li>Finished</li></ol><h3 id="步骤一：客户端发送请求（Client-Hello）"><a href="#步骤一：客户端发送请求（Client-Hello）" class="headerlink" title="步骤一：客户端发送请求（Client Hello）"></a>步骤一：客户端发送请求（Client Hello）</h3><p>首先，客户端向服务端提供加密信息的通信。</p><ol><li>客户端支持的SSL的指定版本</li><li>客户端产生的随机数（Client Random, 稍后用于生成”对话密钥”</li><li>客户端支持的加密算法</li></ol><h3 id="步骤二：服务器回应（Sever-Hello）"><a href="#步骤二：服务器回应（Sever-Hello）" class="headerlink" title="步骤二：服务器回应（Sever Hello）"></a>步骤二：服务器回应（Sever Hello）</h3><p>服务端收到请求，向客户端发出回应</p><ol><li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li><li>一个服务器生成的随机数(Server Random)，稍后用于生成”对话密钥”。</li><li>确认使用的加密方法，比如RSA公钥加密。</li><li>服务器证书</li></ol><p><em>第一次握手结束</em></p><h3 id="步骤三：发送验证消息"><a href="#步骤三：发送验证消息" class="headerlink" title="步骤三：发送验证消息"></a>步骤三：发送验证消息</h3><p>SSL服务器将数字证书通过Certificate消息发送给SSL客户端，证书里面包含了网站地址，加密公钥，以及证书的颁发机构。</p><h3 id="步骤四：服务器回应结束"><a href="#步骤四：服务器回应结束" class="headerlink" title="步骤四：服务器回应结束"></a>步骤四：服务器回应结束</h3><p>SSL服务器发送Server Hello Done消息，通知SSL客户端版本和加密套件协商结束，开始进行密钥交换。</p><h3 id="步骤五："><a href="#步骤五：" class="headerlink" title="步骤五："></a>步骤五：</h3><p>SSL客户端验证SSL服务器的证书合法后，如果不合法浏览器会提示。如果合法的话，利用证书中的公钥，SSL客户端随机生成的premaster secret（后续加密数据所需要的对称密钥），并通过Client Key Exchange消息发送给SSL服务器。</p><p><em>第二次握手结束</em></p><h3 id="步骤六："><a href="#步骤六：" class="headerlink" title="步骤六："></a>步骤六：</h3><p>SSL客户端发送Change Cipher Spec消息，通知SSL服务器后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。</p><h3 id="步骤七："><a href="#步骤七：" class="headerlink" title="步骤七："></a>步骤七：</h3><p>SSL客户端计算已交互的握手消息（除Change Cipher Spec消息外所有已交互的消息）的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL服务器。SSL服务器利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。</p><h3 id="步骤八："><a href="#步骤八：" class="headerlink" title="步骤八："></a>步骤八：</h3><p>同样地，SSL服务器发送Change Cipher Spec消息，通知SSL客户端后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。</p><h3 id="步骤九："><a href="#步骤九：" class="headerlink" title="步骤九："></a>步骤九：</h3><p>SSL服务器计算已交互的握手消息的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL客户端。SSL客户端利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。</p><p><em>第三次握手结束</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;来自&lt;a href=&quot;https://github.com/Advanced-Frontend/Daily-Interview-Question&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Daily-Interview-Question
      
    
    </summary>
    
      <category term="面试" scheme="http://blog.zhyat.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="网络" scheme="http://blog.zhyat.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript问答</title>
    <link href="http://blog.zhyat.cn/2019/03/29/JavaScript%E9%97%AE%E7%AD%94/"/>
    <id>http://blog.zhyat.cn/2019/03/29/JavaScript问答/</id>
    <published>2019-03-28T19:32:44.976Z</published>
    <updated>2019-06-02T07:16:08.003Z</updated>
    
    <content type="html"><![CDATA[<p>Q：为什么有的编程规范要求用void 0 代替 undefined?<br>A: undefined 是一个全局变量，可以被修改。为了准备的表达“未定义”，所以使用void 0</p><p>Q：underfined 与 null 的区别？<br>A：underfined 是Underfined类型的一个值，是一个名为underfined的变量，表达的意思是“从未赋值”“从未定义”，而null是Nulll类型的一个值，是JavaSript语言的关键字，表达的意思是“定义了但是为空”</p><p>Q：0.1+0.2 不能 = 0.3？怎么比较浮点数？<br>A：Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON，浮点数的特性决定了等式两边相差了微小的值，应该比较等式两边之差是否小于最小精度值</p><p>Q：为什么parseInt推荐传入第二个参数？<br>A：在不传入第二个参数的时候，parseInt默认转换0x开头的16进制，还支持0开头的八进制，所以推荐在任何时候都传入第二个参数。parseFloat则直接把字符串作为十进制解析。多数情况下，Number是比parseInt和parseFloat更好的选择。</p><p>Q：instanceof、typeof 和 Object.prototype.toString的区别？<br>Q：[‘1’,’2’,’3’].map(parseInt)的结果？</p><p>Q: 一个页面如果有一万个Bottom如何绑定事件？<br>A：事件委托，绑定父节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.list'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">// 绑定事件到父节点</span></span><br><span class="line">    <span class="built_in">console</span>.log($(event.target).html()); <span class="comment">// 注意操作对象是event.target还是this，下面会有详细说明哦</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'.list'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.target.tagName === <span class="string">'LI'</span>) &#123; <span class="comment">// 判断标签是不是li，注意tagName属性返回的是大写</span></span><br><span class="line">        <span class="built_in">console</span>.log($(event.target).html());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Q: 我们现在要实现一个红绿灯，把一个圆形 div 绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色<br>A:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        setTimeout(resolve, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params">duration,color</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"traffic-light"</span>).style.background = color;</span><br><span class="line">    <span class="keyword">await</span> sleep(duration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">await</span> changeColor(<span class="number">3000</span>,<span class="string">"green"</span>);</span><br><span class="line">        <span class="keyword">await</span> changeColor(<span class="number">1000</span>, <span class="string">"yellow"</span>);</span><br><span class="line">        <span class="keyword">await</span> changeColor(<span class="number">2000</span>, <span class="string">"red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Q：为什么有的编程规范要求用void 0 代替 undefined?&lt;br&gt;A: undefined 是一个全局变量，可以被修改。为了准备的表达“未定义”，所以使用void 0&lt;/p&gt;
&lt;p&gt;Q：underfined 与 null 的区别？&lt;br&gt;A：underfined 
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
      <category term="面试" scheme="http://blog.zhyat.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析</title>
    <link href="http://blog.zhyat.cn/2019/03/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://blog.zhyat.cn/2019/03/28/复杂度分析/</id>
    <published>2019-03-27T23:51:42.105Z</published>
    <updated>2019-06-02T07:16:08.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;      </span><br><span class="line">        sum = sum + i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行代码执行的时间为unit_time<br>第4行第5行分别执行了n遍，所以是 2*n unit_time</p><p>T(n) = O(f(n))<br>T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用f(n)来表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ol><li>只关注执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ol><h3 id="最好、最坏时间复杂度"><a href="#最好、最坏时间复杂度" class="headerlink" title="最好、最坏时间复杂度"></a>最好、最坏时间复杂度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;   </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; ++i) </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) </span><br><span class="line">        pos = i;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> pos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中时间度复杂度会因为x在不在数组中变化，如果x在数组中则O(n)=1,否则O(n)=n。</p><h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><p>要查找的变量x在数组中的位置，有n+1种情况：在数组的0～n-1位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以n+1，就可以得到需要遍历的元素个数的平均值：</p><p>$$<br>\frac{1+2+3+\cdots+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}<br>$$</p><p>考虑到在数组里和不在数组里的概率，以及出现在每个位置的概率，实际上应该是<br>$$<br>\begin{aligned} &amp; 1 \times \frac{1}{2 n}+2 \times \frac{1}{2 n}+3 \times \frac{1}{2 n}+\dots+n \times \frac{1}{2 n}+n \times \frac{1}{2}\ = &amp;\frac{3 n+1}{4} \end{aligned}<br>$$</p><p>用大O表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是O(n)。</p><h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array表示一个长度为n的数组 </span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n  </span></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];  </span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) </span><br><span class="line">        &#123;           </span><br><span class="line">            sum = sum + <span class="built_in">array</span>[i];        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">array</span>[<span class="number">0</span>] = sum;        </span><br><span class="line">        count = <span class="number">1</span>;     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="built_in">array</span>[count] = val;     </span><br><span class="line">    ++count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>1 \times \frac{1}{n+1}+1 \times \frac{1}{n+1}+\dots+1 \times \frac{1}{n+1}+n \times \frac{1}{n+1}=O(1)<br>$$</p><p>每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为10的数组array，长度len，下标i。</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len) <span class="comment">// 数组空间不够了 重新申请一个2倍大小的数组空间</span></span><br><span class="line">    &#123;          </span><br><span class="line">        <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];      </span><br><span class="line">        <span class="comment">// 把原来array数组中的数据依次copy到new_array      </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) </span><br><span class="line">        &#123;        </span><br><span class="line">            new_array[j] = <span class="built_in">array</span>[j];      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">// new_array复制给array，array现在大小就是2倍len了     </span></span><br><span class="line">        <span class="built_in">array</span> = new_array;      </span><br><span class="line">        len = <span class="number">2</span> * len;    </span><br><span class="line">    &#125;    <span class="comment">// 将element放到下标为i的位置，下标i加一   </span></span><br><span class="line">    <span class="built_in">array</span>[i] = element;   </span><br><span class="line">    ++i; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<br>   最好：O(1)<br>   最坏：O(n)<br>   均摊：O(1) 因为前N个操作都是O(1),最后一个均摊到前n个</p><p>空间复杂度：<br>   最好：O(1)<br>   最坏：O(n)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h2&gt;&lt;h3 id=&quot;大O表示法&quot;&gt;&lt;a href=&quot;#大O表示法&quot; class=&quot;headerlink&quot; title=&quot;大O表
      
    
    </summary>
    
      <category term="数据结构" scheme="http://blog.zhyat.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构之美" scheme="http://blog.zhyat.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BE%8E/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的“面向对象”</title>
    <link href="http://blog.zhyat.cn/2019/02/19/JavaScript%E5%AE%9E%E7%8E%B0%E5%A4%8D%E7%94%A8/"/>
    <id>http://blog.zhyat.cn/2019/02/19/JavaScript实现复用/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-06-02T07:16:08.002Z</updated>
    
    <content type="html"><![CDATA[<p>在实现面向对象的编程中，有两种不同的描述对象的方式。一是以Java、C++为代表的基于类的编程语言，二是以JavaScript为代表的基于原型的编程语言。<br>基于“类”关心分类与类，基于“原型”则更关心对象实例。基于“类”的语言总是先有类，然后再去实例化一个对象，类与类之间可以形成继承、组合等关系。但基于”原型“的语言是通过“复制”来创建新的对象。<br>为了使JavaScript更接近基于“类”的实现方式，社区里曾有过不少接近于类Java的风格方言。但在ES6出现后，<code>class</code>已经成为一个关键字，不需要模拟即可实现“类”，但实际上这个“类”还是基于原型对象之上的。</p><p>利用class实现继承<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>可以跑`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>可以四肢腿跑`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>可以两只腿跑`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>)</span><br><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> Duck(<span class="string">'Donald'</span>)</span><br><span class="line"></span><br><span class="line">cat.run() <span class="comment">// Tom可以四肢腿跑</span></span><br><span class="line">duck.run()<span class="comment">// Donald可以两只腿跑</span></span><br></pre></td></tr></table></figure></p><p>当然，ES6在操作对象上也提供了几个方法，使得基于原型的思想也同样可以实现继承。提供的方法如下：</p><ul><li><code>Object.create</code></li><li><code>Object.getPrototypeOf</code></li><li><code>Object.sePrototypeOf</code><br>这三个方法具体如何使用请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">MDN</a></li></ul><p>用原型实现的继承<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  run()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我可以跑'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="built_in">Object</span>.create(animal,&#123;</span><br><span class="line">  say()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是cat'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> duck = <span class="built_in">Object</span>.create(animal,&#123;</span><br><span class="line">  say()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是duck'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someCat = <span class="built_in">Object</span>.create(cat)</span><br><span class="line"><span class="keyword">let</span> someDuck = <span class="built_in">Object</span>.create(duck)</span><br><span class="line"></span><br><span class="line">someCat.say()</span><br><span class="line">someDuck.say()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实现面向对象的编程中，有两种不同的描述对象的方式。一是以Java、C++为代表的基于类的编程语言，二是以JavaScript为代表的基于原型的编程语言。&lt;br&gt;基于“类”关心分类与类，基于“原型”则更关心对象实例。基于“类”的语言总是先有类，然后再去实例化一个对象，类与类
      
    
    </summary>
    
      <category term="前端" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhyat.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>回顾2018</title>
    <link href="http://blog.zhyat.cn/2018/12/09/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.zhyat.cn/2018/12/09/2018年终总结/</id>
    <published>2018-12-08T16:00:00.000Z</published>
    <updated>2019-02-19T03:40:32.771Z</updated>
    
    <content type="html"><![CDATA[<p>一年总是转瞬即逝，大学生涯在这一年悄悄的结束，曾经很难想像的生活就这样猝不及防的到了自己面前，好像什么也没准备好就被推到了生活的前面，成了潮水本身。好像越是长大，对时间的感知越是迟钝。十年之前，一年好像是很久很久才会过完的，而到了如今一年又一年，不过一眨眼的事情。</p><a id="more"></a><p>回顾这一年，经历了很多事情，毕业、工作、独自生活，这些在当时看起来很难的事情，现在却已经无法回顾当时的心情，可能人的确是善于遗忘苦难的。</p><p>少年时便离家读书，再加之自己从来也不喜欢热闹，以为自己是惯于自己生活的，可真正独居便还是会常常觉得寂寞。仔细想想，较之从前那十年，现在回到住处可没有舍友可以嬉笑怒骂啊，有时下班得早竟也会觉得无事可做，渐渐地便也不愿早早下班了。有时候深夜醒来，还是恍惚，难道我就这样长大了吗？好像是的，尽管没人教会我，但我好像就这样长大了。</p><p>刚毕业时，并没有什么太大的感觉，和舍友道别也不曾觉得感伤，却在时隔半年以后突然感到慌张，“啊？我就这样毕业了吗？”大学四年如今想来甚是浪费，在旁人眼里算是多姿多彩，我却晓得其中是多么的空洞无物，还能想起来大三的时候，自己是多么的为自己的无知感到焦虑，常常在半夜四点醒来，感叹自己这一天又什么都没做成，而如今其实也没有什么改变，却甚是心安理得，到底也是屈从于生活了。</p><p>每日干着重复的工作，想去学习却总是给自己找借口说没有时间，甚至于大学时候坚持了许久的跑步也开始落下，这一年是不能让我满意的。找到工作没有费什么劲，只不过是自己也没考虑好自己想要什么，若是新的一年还是如此，便太过于懒散了。</p><p>我知道什么时候开始做一件事都不算晚，我也不愿意把什么事情都拖到来年再说，那么至少在年末之前，把《高级程序设计》和《语言精粹》再精读一遍吧。</p><p>永远不要停止学习，永远不要忘记自己的无知。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年总是转瞬即逝，大学生涯在这一年悄悄的结束，曾经很难想像的生活就这样猝不及防的到了自己面前，好像什么也没准备好就被推到了生活的前面，成了潮水本身。好像越是长大，对时间的感知越是迟钝。十年之前，一年好像是很久很久才会过完的，而到了如今一年又一年，不过一眨眼的事情。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://blog.zhyat.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://blog.zhyat.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>js 必须写分号的几种情况</title>
    <link href="http://blog.zhyat.cn/2018/09/07/JS%E5%BF%85%E9%A1%BB%E5%86%99%E5%88%86%E5%8F%B7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>http://blog.zhyat.cn/2018/09/07/JS必须写分号的几种情况/</id>
    <published>2018-09-06T16:00:00.000Z</published>
    <updated>2019-02-19T03:34:28.198Z</updated>
    
    <content type="html"><![CDATA[<p>关于 js 写不写分号其实应该算是风格问题，我不写分号的原因觉得 “知道什么时候该加分号比任何时候都加分号要好”，而且我懒。<br><a id="more"></a></p><h3 id="return-语句折行"><a href="#return-语句折行" class="headerlink" title="return 语句折行"></a>return 语句折行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">a:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在 <code>return</code>后加上分号</p><h3 id="、-、-、"><a href="#、-、-、" class="headerlink" title="[ 、 ( 、 + 、 -"></a>[ 、 ( 、 + 、 -</h3><p>这些情况，在前面加个分号就行。<br>最常见到的就是立即执行函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>其次就是forEach了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 js 写不写分号其实应该算是风格问题，我不写分号的原因觉得 “知道什么时候该加分号比任何时候都加分号要好”，而且我懒。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="笔记" scheme="http://blog.zhyat.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组的多种解法</title>
    <link href="http://blog.zhyat.cn/2018/09/05/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%A7%A3%E6%B3%95/"/>
    <id>http://blog.zhyat.cn/2018/09/05/旋转数组的多种解法/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2019-02-19T03:41:18.361Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的原地算法。</li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>执行时间：140 ms 空间复杂度： 时间复杂度：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = nums.splice( nums.length-k, k )</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = temp.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        nums.unshift( temp[i] )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>执行时间</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="笔记" scheme="http://blog.zhyat.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="LeetCode" scheme="http://blog.zhyat.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Typescript 学习笔记—基本语法</title>
    <link href="http://blog.zhyat.cn/2018/09/05/TypeScript%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.zhyat.cn/2018/09/05/TypeScript 入门笔记/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2019-02-19T03:35:09.438Z</updated>
    
    <content type="html"><![CDATA[<p>为什么使用Typescript？类型系统使代码的可读性更高，扩展性好，是JS的超集。</p><a id="more"></a><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="定义变量类型"><a href="#定义变量类型" class="headerlink" title="定义变量类型"></a>定义变量类型</h2><ul><li>如果在定义的时候没有定义类型，TS会自动做类型推论<h3 id="原始数据类型-（Primitive-data-types）"><a href="#原始数据类型-（Primitive-data-types）" class="headerlink" title="原始数据类型 （Primitive data types）"></a>原始数据类型 （Primitive data types）</h3>布尔值、数值、字符串、null、undefined 、Symbol</li></ul><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bur: <span class="built_in">boolean</span> = <span class="literal">false</span> ;</span><br></pre></td></tr></table></figure><p>但需要注意的是用<code>Boolean</code>构造函数创造的不是布尔值而是<code>Boolean</code>对象<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> creatBoolean: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br></pre></td></tr></table></figure></p><h4 id="数值（number"><a href="#数值（number" class="headerlink" title="数值（number)"></a>数值（number)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: <span class="built_in">number</span> = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: <span class="built_in">number</span> = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="keyword">let</span> myAge: <span class="built_in">number</span> = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.</span></span><br></pre></td></tr></table></figure><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>可以用来表示没有返回值的函数</p><h3 id="NULL和-Undefined"><a href="#NULL和-Undefined" class="headerlink" title="NULL和 Undefined"></a>NULL和 Undefined</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><code>undefined</code> 类型的变量只能被赋值为 <code>undefined</code>，<code>null</code> 类型的变量只能被赋值为 <code>null</code>。</p><h3 id="对象类型（Object-types）"><a href="#对象类型（Object-types）" class="headerlink" title="对象类型（Object types）"></a>对象类型（Object types）</h3><h3 id="任意值-（Any）"><a href="#任意值-（Any）" class="headerlink" title="任意值 （Any）"></a>任意值 （Any）</h3><p>只有 Any 类型的值允许被赋值成任何类型<br>可以在任意值上访问任意属性和任意方法<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></p><p>** 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 *\*</p><h3 id="未声明类型"><a href="#未声明类型" class="headerlink" title="未声明类型"></a>未声明类型</h3><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型<br>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型</p><h3 id="联合类型-Union-Types）"><a href="#联合类型-Union-Types）" class="headerlink" title="联合类型(Union Types）"></a>联合类型(Union Types）</h3><p>取值可以为多种类型中的一种<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber: <span class="built_in">String</span> | <span class="built_in">Number</span>;</span><br><span class="line">myFavoriteNumber  = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber  = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></p><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么使用Typescript？类型系统使代码的可读性更高，扩展性好，是JS的超集。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="TypeScript" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/TypeScript/"/>
    
    
      <category term="笔记" scheme="http://blog.zhyat.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用Jest测试JavaScript</title>
    <link href="http://blog.zhyat.cn/2018/09/04/%E4%BD%BF%E7%94%A8Jest%E6%B5%8B%E8%AF%95JavaScript/"/>
    <id>http://blog.zhyat.cn/2018/09/04/使用Jest测试JavaScript/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2018-09-04T13:26:27.844Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Jest 是 Facebook 的一套开源的 JavaScript 测试框架， 它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架。并且它对同样是 Facebook 的开源前端框架 React 的测试十分友好。</p></blockquote><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>npm init -y</li><li>npm install -D jest babel-jest babel-core babel-preset-env regenerator-runtime</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>在项目根目录添加<code>.babelrc</code>文件</li><li><p>在文件中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打开<code>package.json</code>文件，将<code>script</code>下的<code>test</code>的值修改为<code>jest</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "jest"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="编写测试方法"><a href="#编写测试方法" class="headerlink" title="编写测试方法"></a>编写测试方法</h2><ol><li><p>创建<code>src</code>和<code>test</code>目录及相关文件</p><ul><li>在项目根目录下创建<code>src</code>目录，并在<code>src</code>目录下添加<code>functions.js</code>文件</li><li>在项目根目录下创建<code>test</code>目录，并在<code>test</code>目录下创建<code>functions.test.js</code>文件</li><li>测试文件的文件名 = 被测试模块名 + .test.js，例如被测试模块为<code>functions.js</code>，那么对应的测试文件命名为<code>functions.test.js</code>。</li><li><code>Jest</code> 会自动找到项目中所有使用<code>.spec.js</code>或<code>.test.js</code>文件命名的测试文件并执行</li></ul></li><li><p>在<code>src/functions.js</code>中创建被测试的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  sum(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>test/functions.test.js</code>文件中创建测试用例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functions  <span class="keyword">from</span> <span class="string">'../src/functions'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'sum(2 + 2) 等于 4'</span>, () =&gt; &#123;</span><br><span class="line">  expect(functions.sum(<span class="number">2</span>, <span class="number">2</span>)).toBe(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Jest 是 Facebook 的一套开源的 JavaScript 测试框架， 它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架。并且它对同样是 Facebook 的开源前端框架 React 的测试十分友好。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="测试" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="使用说明" scheme="http://blog.zhyat.cn/tags/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>移动端滑动事件</title>
    <link href="http://blog.zhyat.cn/2018/09/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.zhyat.cn/2018/09/04/移动端滑动事件/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2018-12-09T12:43:00.464Z</updated>
    
    <content type="html"><![CDATA[<p>在移动端滑动，在一次滑动中可能触发多次事件，通过加锁可以解决</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 左滑</span></span><br><span class="line"><span class="comment">    * @param &#123;object&#125; e 事件对象</span></span><br><span class="line"><span class="comment">    * @returns &#123;boolean&#125; 布尔值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">isLeftSlide</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> startX = gesture.startX;</span><br><span class="line">    <span class="keyword">var</span> startY = gesture.startY;</span><br><span class="line">     <span class="keyword">if</span> (gesture.slideLock) &#123;</span><br><span class="line">       <span class="keyword">var</span> t = e.originalEvent.changedTouches[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> deltaX = t.clientX - startX</span><br><span class="line">       <span class="keyword">var</span> deltaY = t.clientY - startY</span><br><span class="line">       <span class="keyword">if</span> (deltaX &lt; <span class="number">-20</span> &amp;&amp; deltaX &gt; <span class="number">-40</span> &amp;&amp; deltaY &lt; <span class="number">8</span> &amp;&amp; deltaY &gt; <span class="number">-8</span>) &#123;</span><br><span class="line">         gesture.slideLock = <span class="literal">false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 右滑</span></span><br><span class="line"><span class="comment">    * @param &#123;object&#125; e 事件对象</span></span><br><span class="line"><span class="comment">    * @returns &#123;boolean&#125; 布尔值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">isRightSlide</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> startX = gesture.startX;</span><br><span class="line">       <span class="keyword">var</span> startY = gesture.startY;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (gesture.slideLock) &#123;</span><br><span class="line">       <span class="keyword">var</span> t = e.originalEvent.changedTouches[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> deltaX = t.clientX - startX</span><br><span class="line">       <span class="keyword">var</span> deltaY = t.clientY - startY</span><br><span class="line">       <span class="keyword">if</span> (deltaX &gt; <span class="number">20</span> &amp;&amp; deltaX &lt; <span class="number">40</span> &amp;&amp; deltaY &lt; <span class="number">8</span> &amp;&amp; deltaY &gt; <span class="number">-8</span>) &#123;</span><br><span class="line">         gesture.slideLock = <span class="literal">false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">touchstart</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'e'</span>,e);</span><br><span class="line">       <span class="keyword">var</span> t = e.originalEvent.changedTouches[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> startX = t.clientX;</span><br><span class="line">       <span class="keyword">var</span> startY = t.clientY;</span><br><span class="line">       gesture.slideLock = <span class="literal">true</span>; <span class="comment">// 滑动事件加锁</span></span><br><span class="line"></span><br><span class="line">       gesture.startX = startX;</span><br><span class="line">       gesture.startY = startY;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">touchmove</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isLeftSlide(e)) &#123;</span><br><span class="line">         alert(<span class="string">'left'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isRightSlide(e)) &#123;</span><br><span class="line">        alert(<span class="string">'right'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   $(<span class="string">'body'</span>).touchstart(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">       touchstart(e);</span><br><span class="line">   &#125;);</span><br><span class="line">   $(<span class="string">'body'</span>).touchmove(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">       touchmove(e);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在移动端滑动，在一次滑动中可能触发多次事件，通过加锁可以解决&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JQuery" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/JQuery/"/>
    
    
      <category term="笔记" scheme="http://blog.zhyat.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>同步微博到推特或脸书</title>
    <link href="http://blog.zhyat.cn/2018/03/09/%E5%90%8C%E6%AD%A5%E5%BE%AE%E5%8D%9A%E5%88%B0%E6%8E%A8%E7%89%B9%E6%88%96%E8%84%B8%E4%B9%A6/"/>
    <id>http://blog.zhyat.cn/2018/03/09/同步微博到推特或脸书/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2018-12-09T12:43:08.588Z</updated>
    
    <content type="html"><![CDATA[<p>同步微博到推特或脸书</p><a id="more"></a><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><ol><li>在 <a href="https://ifttt.com/" target="_blank" rel="noopener">IFTTT</a> 注册一个帐号</li><li>在 <a href="https://www.integromat.com/" target="_blank" rel="noopener">integromat</a> 注册一个帐号</li></ol><p><em>这两个网站均可以用 Google 或 FB 帐号登录。</em></p><h4 id="在-IFTTT-上添加-“发送新微博的触发”"><a href="#在-IFTTT-上添加-“发送新微博的触发”" class="headerlink" title="在 IFTTT 上添加 “发送新微博的触发”"></a>在 <a href="https://ifttt.com/" target="_blank" rel="noopener">IFTTT</a> 上添加 “发送新微博的触发”</h4><h5 id="连接-Weibo-、Facebook-、Twitter"><a href="#连接-Weibo-、Facebook-、Twitter" class="headerlink" title="连接 Weibo 、Facebook 、Twitter"></a>连接 Weibo 、Facebook 、Twitter</h5><ol><li>在 IFTTT 的主页面，点击 Search</li><li>分别搜索 Weibo 、Facebook 、Twitter</li><li>以 Weibo 为例，搜索框输入 Weibo 之后，点击 Services 下的图标，在弹出的新页面选择授权</li></ol><h5 id="同步原创纯文本微博"><a href="#同步原创纯文本微博" class="headerlink" title="同步原创纯文本微博"></a>同步原创纯文本微博</h5><h6 id="1-Facebook"><a href="#1-Facebook" class="headerlink" title="1. Facebook"></a>1. Facebook</h6><ul><li>点击在右上角用户名下拉框，选择 New Applet</li><li>点击页面上蓝色字  this</li><li>在 Search services 搜索  webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger</li><li>点击页面上蓝色字 that</li><li>在 Search services 搜索  Facebook，依次点击 Facebook -> Creat a status message，Status message 中填写  ，点击  Create action</li><li>点击 Finish</li></ul><h6 id="2-Twitter"><a href="#2-Twitter" class="headerlink" title="2. Twitter"></a>2. Twitter</h6><ul><li>点击在右上角用户名下拉框，选择 New Applet</li><li>点击页面上蓝色字  this</li><li>在 Search services 搜索  webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger</li><li>点击页面上蓝色字 that</li><li>在 Search services 搜索 Twitter，依次点击 Twitter -> Post a tweet，Tweet text 中填写  ，点击  Create action</li><li>点击 Finish</li></ul><h5 id="同步原创带图片微博"><a href="#同步原创带图片微博" class="headerlink" title="同步原创带图片微博"></a>同步原创带图片微博</h5><h6 id="1-Facebook-1"><a href="#1-Facebook-1" class="headerlink" title="1. Facebook"></a>1. Facebook</h6><ul><li>点击在右上角用户名下拉框，选择 New Applet</li><li>点击页面上蓝色字  this</li><li>在 Search services 搜索  webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 ImageWeibo，点击 Creat trigger</li><li>点击页面上蓝色字 that</li><li>在 Search services 搜索  Facebook，依次点击 Facebook -> Upload a photo from URL，Message 中填写  ，Photo Url 中填写  ，点击  Create action</li><li>点击 Finish</li></ul><h6 id="2-Twitter-1"><a href="#2-Twitter-1" class="headerlink" title="2. Twitter"></a>2. Twitter</h6><ul><li><p>点击在右上角用户名下拉框，选择 New Applet</p></li><li><p>点击页面上蓝色字  this</p></li><li><p>在 Search services 搜索  webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger</p></li><li><p>点击页面上蓝色字 that</p></li><li><p>在 Search services 搜索  Twitter，依次点击 Twitter -> Post a tweet with image</p></li></ul><p>，Tweet text 中填写  ，Image URL 填写  ，点击  Create action</p><ul><li>点击 Finish</li></ul><h5 id="webhook-的触发地址"><a href="#webhook-的触发地址" class="headerlink" title="webhook 的触发地址"></a>webhook 的触发地址</h5><ul><li>点击在右上角用户名下拉框，选择 Services</li><li>搜索 Webhooks</li><li>点击 Documentation</li><li>将 Key 记下来</li></ul><p><em>因为 IFTTT 发送带图片和不带图片是不同的方式，所以必须设置两个 IFTTT 的 APPLET</em></p><h4 id="通过-integromat-将两条规则分发"><a href="#通过-integromat-将两条规则分发" class="headerlink" title="通过 integromat 将两条规则分发"></a>通过 <a href="https://www.integromat.com/" target="_blank" rel="noopener">integromat</a> 将两条规则分发</h4><h5 id="1-设置-webhook"><a href="#1-设置-webhook" class="headerlink" title="1. 设置 webhook"></a>1. 设置 webhook</h5><ul><li>选择 Create a new scenario</li></ul><ul><li>点击？号图标，搜索 webhook</li><li>依次选择 webhooks -> Custom Webhook</li><li>点击 Webhooks 的图标，点击下拉框旁的 Add</li><li>Webhook name 填写 IFTTT weibo webhook</li><li>点击左下角的 Show advanced settings</li><li>Data structure 右侧点击 Add</li><li>Data Structure name 填写 Weibo data structure</li><li>点击 Generator</li><li>Content type 选择 Query String</li><li>Sample data 填写：text=text&amp;image=imageUrl</li><li>点击 Save , 点击 Add data structure 表单的 Save，点击 Add a hook 表单的 Save</li></ul><p><img src="//blog.zhyat.cn/2018/03/09/同步微博到推特或脸书/webhook.gif" alt="webhook"></p><h5 id="2-测试是否正常工作"><a href="#2-测试是否正常工作" class="headerlink" title="2. 测试是否正常工作"></a>2. 测试是否正常工作</h5><ul><li>复制 Webhooks 表单中给出的 URL</li><li>在这个 URL 后面拼接 ?text=text&amp;image=imageUrl</li><li>在浏览器地址栏中粘贴</li><li>若 Webhooks 表单给出 Successfuly determined 表示成功运转</li><li>然后将 Webhooks 表单中给出的 URL 记录下来</li></ul><p><img src="//blog.zhyat.cn/2018/03/09/同步微博到推特或脸书/%E6%B5%8B%E8%AF%95%E8%BF%90%E8%BD%AC.jpg" alt="测试运转"></p><h5 id="3-设置-Router"><a href="#3-设置-Router" class="headerlink" title="3. 设置 Router"></a>3. 设置 Router</h5><ul><li><p>点 webhook 图标右边的半圆，选择 Router</p></li><li><p>设置第一条</p><ul><li>点第一条分支的虚线中间部分，点击 set up a filter</li><li>Lable 填 Image weibo，Condition 输入框选左边的 image，下拉框选择 exists，点击 ok</li><li>点击这条分支的末端图标问号，搜索 HTTP</li><li>点击 HTTP，选择 Make a request</li><li>在 <a href="https://maker.ifttt.com/trigger/imageWeibo/with/key/" target="_blank" rel="noopener">https://maker.ifttt.com/trigger/imageWeibo/with/key/</a> 后加上在 IFTTT 步骤记录下来的 Key</li><li>Method 选择 POST，Body Type 选择 application/x-www-form-urlencode</li><li>点击 Add item，Key 填 value1，点击 value 的输入框，选择 text</li><li>点击 Add item，key 填写 value2，点击 value 的输入框，选择 image</li><li>点击 ok</li></ul></li><li><p>设置第二条</p><ul><li>点第二条分支的虚线中间部分，点击 set up a filter</li><li>Lable 填 Text weibo，Condition 输入框选左边的 image，下拉框选择 Does not exist </li><li>点击右下角 Add and rule，点击输入框，选择 text，下拉框选择 Dose not matches Pattern (case insensitive)，下面的输入框输入 (Repost)|(转发微博）|(\/\/)|( 轉發微博，点击 ok</li><li>点击这条分支的末端图标问号，搜索 HTTP</li><li>点击 HTTP，选择 Make a request</li><li>在 <a href="https://maker.ifttt.com/trigger/imageWeibo/with/key/" target="_blank" rel="noopener">https://maker.ifttt.com/trigger/imageWeibo/with/key/</a> 后加上在 IFTTT 步骤记录下来的 Key</li><li>Method 选择 POST，Body Type 选择 application/x-www-form-urlencode</li><li>点击 Add item，Key 填 value1，点击 value 的输入框，选择 text</li><li>点击 ok</li></ul><p>上述步骤完成后，点击右下角保存，并确定此 scenarios 正在运行</p></li></ul><h4 id="在-IFTTT-中创建触发器"><a href="#在-IFTTT-中创建触发器" class="headerlink" title="在 IFTTT 中创建触发器"></a>在 IFTTT 中创建触发器</h4><ul><li>点击页面上蓝色字  this</li><li>在 Search services 搜索  weibo，选择 New post by you，点击 Creat trigger</li><li>点击页面上蓝色字 that</li><li>在 Search services 搜索 webhook，选择 Make a Web request，在 URL 中填写在 integromat Webhooks 表单中拿到的 URL，点击  Create action</li><li>点击 Finish</li></ul><p>然后就可以同步微博上的原创微博了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步微博到推特或脸书&lt;/p&gt;
    
    </summary>
    
      <category term="软件" scheme="http://blog.zhyat.cn/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="使用说明" scheme="http://blog.zhyat.cn/tags/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>Python 科学计算可视化--管线与数据加载</title>
    <link href="http://blog.zhyat.cn/2017/12/19/Tvtk%E7%AE%A1%E7%BA%BF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD/"/>
    <id>http://blog.zhyat.cn/2017/12/19/Tvtk管线与数据加载/</id>
    <published>2017-12-18T16:00:00.000Z</published>
    <updated>2019-06-02T07:16:08.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管线（Pipeline）"><a href="#管线（Pipeline）" class="headerlink" title="管线（Pipeline）"></a>管线（Pipeline）</h2><p><img src="//blog.zhyat.cn/2017/12/19/Tvtk管线与数据加载/可视化.png" alt="可视化"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tvtk.api <span class="keyword">import</span> tvtk</span><br><span class="line"><span class="comment"># 可视化管线</span></span><br><span class="line"><span class="comment"># 创建一个长方体数据源 </span></span><br><span class="line">s = tvtk.CubeSource(x_length=<span class="number">1.0</span>, y_length=<span class="number">2.0</span>, z_length=<span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 将其映射为图形数据 </span></span><br><span class="line">m = tvtk.PolyDataMapper(input_connection=s.output_port)</span><br><span class="line"><span class="comment"># 图形管线</span></span><br><span class="line"><span class="comment"># 创建一个Actor </span></span><br><span class="line">a = tvtk.Actor(mapper=m)</span><br><span class="line"><span class="comment"># 创建一个Rnderer </span></span><br><span class="line">r = tvtk.Renderer(background=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 将Actor添加到Renderer中 </span></span><br><span class="line">r.add_actor(a)</span><br><span class="line"><span class="comment"># 创建一个窗口 </span></span><br><span class="line">w = tvtk.RenderWindow(size=(<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line"><span class="comment"># 将Renderer添加到窗口中 </span></span><br><span class="line">w.add_renderer(r)</span><br><span class="line"><span class="comment"># 添加交互工具 </span></span><br><span class="line">i = tvtk.RenderWindowInteractor(render_window=w)</span><br><span class="line"><span class="comment"># 开启交互 </span></span><br><span class="line">i.initialize()</span><br><span class="line">i.start()</span><br></pre></td></tr></table></figure><h3 id="可视化管线"><a href="#可视化管线" class="headerlink" title="可视化管线"></a>可视化管线</h3><p>将原始数据加工成图形数据的过程</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>CubeSourece</td><td>通过程序内部计算输出一组描述长方体的数据（PloyData）</td></tr><tr><td>PolyDataMapper</td><td>PolyData通过该映射器将数据映射为图形数据（mapper）</td></tr></tbody></table><h3 id="图形管线"><a href="#图形管线" class="headerlink" title="图形管线"></a>图形管线</h3><p>图形数据加工为我们所看到的图像的过程</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Actor</td><td>场景中的一个实体。它包括一个图形数据（mapper），具有描述该实体的位置，方向，大小的属性。</td></tr><tr><td>Renderer</td><td>渲染的场景。它包括多个需要渲染的Actor</td></tr><tr><td>RenderWindow</td><td>渲染用的图形窗口，它包括一个或者多个Render</td></tr><tr><td>RenderWindowInteractor</td><td>给图形窗口提供一些用户交互功能，例如平移、旋转、放大缩小。这些交互式操作并不改变Actor或者图形数据的属性，只是调整场景中的照相机（Camera）的一些设置。</td></tr></tbody></table><h3 id="观察Tvtk的管线"><a href="#观察Tvtk的管线" class="headerlink" title="观察Tvtk的管线"></a>观察Tvtk的管线</h3><p>使用ivtk显示立方体<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tvtk.api <span class="keyword">import</span> tvtk</span><br><span class="line"><span class="keyword">from</span> tvtk.tools <span class="keyword">import</span> ivtk</span><br><span class="line"><span class="keyword">from</span> pyface.api <span class="keyword">import</span> GUI</span><br><span class="line"></span><br><span class="line">s = tvtk.CubeSource(x_length=<span class="number">1.0</span>, y_length=<span class="number">2.0</span>, z_length=<span class="number">3.0</span>)</span><br><span class="line">m = tvtk.PolyDataMapper(input_connection=s.output_port)</span><br><span class="line">a = tvtk.Actor(mapper=m)</span><br><span class="line"><span class="comment"># 创建一个窗口</span></span><br><span class="line">gui = GUI()</span><br><span class="line">win = ivtk.IVTKWithCrustAndBrowser()</span><br><span class="line">win.open()</span><br><span class="line">win.scene.add_actor(a)</span><br><span class="line"><span class="comment"># 修正窗口显示错误</span></span><br><span class="line">dialog = win.control.centralWidget().widget(<span class="number">0</span>).widget(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> pyface.qt <span class="keyword">import</span> QtCore</span><br><span class="line">dialog.setWindowFlags(QtCore.Qt.WindowFlags(<span class="number">0x00000000</span>))</span><br><span class="line">dialog.show()</span><br><span class="line"><span class="comment"># 开始界面消息循环</span></span><br><span class="line">gui.start_event_loop()</span><br></pre></td></tr></table></figure></p><p><img src="//blog.zhyat.cn/2017/12/19/Tvtk管线与数据加载/tools.jpg" alt="tools"></p><h3 id="照相机属性"><a href="#照相机属性" class="headerlink" title="照相机属性"></a>照相机属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>clipping_plane</td><td>它有两个元素，分别表示照相机到近、远两个裁剪 平面的距离。在这两个平面范围之外将不会显示</td></tr><tr><td>position</td><td>照相机在三维空间中的坐标</td></tr><tr><td>focal_point</td><td>照相机所聚焦的焦点坐标</td></tr><tr><td>view_up</td><td>照相机的上方向矢量</td></tr></tbody></table><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ul><li>点（Point）和数据（Data）</li><li>点之间：连接 VS 非连接</li><li>多个相关的点组成单元</li><li>点的连接：显示 VS 隐式</li></ul><h3 id="数据集的类型"><a href="#数据集的类型" class="headerlink" title="数据集的类型"></a>数据集的类型</h3><table><thead><tr><th>数据集</th><th>点的连接</th><th>特点</th></tr></thead><tbody><tr><td>ImageData</td><td>隐式</td><td>二维或三维图像的数据结构</td></tr><tr><td>RectilinearGrid</td><td>隐式</td><td>间距不均匀的网格，所有点都在正交的网格上</td></tr><tr><td>StructuredGild</td><td>隐式</td><td>创建任意形状的网格，需要指定点的坐标</td></tr><tr><td>PolyData</td><td>显式</td><td>由一系列的点、点之间的联系以及由点构成的多边形组成</td></tr></tbody></table><h2 id="Tvtk库的数据加载"><a href="#Tvtk库的数据加载" class="headerlink" title="Tvtk库的数据加载"></a>Tvtk库的数据加载</h2><p>TVTK模型读取<br><code>s = tvtk.STLReader(file_name = &quot;stl文件名&quot;)</code></p><p>TVTK MultiBlock数据读取</p><ul><li>Plot3D</li><li>网格 (XYZ 文件)</li><li>空气动力学结果 (Q 文件)</li><li>通用结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tvtk.api <span class="keyword">import</span> tvtk</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span><span class="comment"># 读入数据</span></span><br><span class="line">    plot3d = tvtk.MultiBlockPLOT3DReader(</span><br><span class="line">            xyz_file_name=<span class="string">"combxyz.bin"</span>,<span class="comment">#网格文件</span></span><br><span class="line">            q_file_name=<span class="string">"combq.bin"</span>,<span class="comment">#空气动力学结果文件</span></span><br><span class="line">            scalar_function_number=<span class="number">100</span>,<span class="comment">#设置标量数据数量</span></span><br><span class="line">            vector_function_number=<span class="number">200</span><span class="comment">#设置矢量数据数量</span></span><br><span class="line">            )</span><br><span class="line">    plot3d.update()</span><br><span class="line">    <span class="keyword">return</span> plot3d</span><br><span class="line"> </span><br><span class="line">plot3d = read_data()</span><br><span class="line">grid = plot3d.output.get_block(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;管线（Pipeline）&quot;&gt;&lt;a href=&quot;#管线（Pipeline）&quot; class=&quot;headerlink&quot; title=&quot;管线（Pipeline）&quot;&gt;&lt;/a&gt;管线（Pipeline）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;//blog.zhyat.cn/2017/12/19/Tvtk管线与数据加载/可视化.png&quot; alt=&quot;可视化&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.zhyat.cn/categories/Python/"/>
    
      <category term="Tvtk" scheme="http://blog.zhyat.cn/categories/Python/Tvtk/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhyat.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="三维可视化" scheme="http://blog.zhyat.cn/tags/%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python 科学计算可视化--三维可视化基础</title>
    <link href="http://blog.zhyat.cn/2017/12/11/Python%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.zhyat.cn/2017/12/11/Python三维可视化基础/</id>
    <published>2017-12-10T16:00:00.000Z</published>
    <updated>2018-09-04T13:26:53.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="科学计算可视化的分类"><a href="#科学计算可视化的分类" class="headerlink" title="科学计算可视化的分类"></a>科学计算可视化的分类</h2><a id="more"></a><h3 id="信息可视化"><a href="#信息可视化" class="headerlink" title="信息可视化"></a>信息可视化</h3><ul><li>信息</li><li>知识</li></ul><h3 id="科学可视化"><a href="#科学可视化" class="headerlink" title="科学可视化"></a>科学可视化</h3><ul><li>空间数据</li></ul><h2 id="科学可视化的可视化方法"><a href="#科学可视化的可视化方法" class="headerlink" title="科学可视化的可视化方法"></a>科学可视化的可视化方法</h2><h3 id="二维标量数据场"><a href="#二维标量数据场" class="headerlink" title="二维标量数据场"></a>二维标量数据场</h3><ul><li>颜色映射法</li><li>等值线方法</li><li>立体图法和层次分割法</li></ul><h3 id="三维标量数据场"><a href="#三维标量数据场" class="headerlink" title="三维标量数据场"></a>三维标量数据场</h3><ul><li>面绘制法</li><li>体绘制法</li></ul><h3 id="矢量数据场"><a href="#矢量数据场" class="headerlink" title="矢量数据场"></a>矢量数据场</h3><ul><li>直接法</li><li>流线法</li></ul><h2 id="TVTK库的安装"><a href="#TVTK库的安装" class="headerlink" title="TVTK库的安装"></a>TVTK库的安装</h2><p>三维可视化工具<br>Windows10 64位 + Python3.6，在库文件所在目录里依次安装：</p><ul><li>VTK-7.1.1-cp36-cp36m-win_amd64.whl</li><li>numpy-1.12.1+mkl-cp36-cp36m-win_amd64.whl</li><li>traits-4.6.0-cp36-cp36m-win_amd64.whl</li><li>mayavi-4.5.0+vtk71-cp36-cp36m-win_amd64.whl</li><li>PyQt4-4.11.4-cp36-cp36m-win_amd64.whl</li></ul><p>在.whl文件目录下用管理员身份运行cmd,在cmd中输入<code>pip install xxx.whl</code></p><h2 id="创建一个TVTK的基本三维对象"><a href="#创建一个TVTK的基本三维对象" class="headerlink" title="创建一个TVTK的基本三维对象"></a>创建一个TVTK的基本三维对象</h2><p><code>s = tvtk.CubeSource(traits)</code></p><h3 id="CubeSoure对象的属性"><a href="#CubeSoure对象的属性" class="headerlink" title="CubeSoure对象的属性"></a>CubeSoure对象的属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>s.x_length</td><td>长方体对象在x轴方向的长度</td></tr><tr><td>s.y_length</td><td>长方体对象在y轴方向的长度</td></tr><tr><td>s.z_length</td><td>长方体对象在z轴方向的长度</td></tr><tr><td>s.center</td><td>长方体对象所在坐标系的原点</td></tr><tr><td>s.output_points_precision</td><td>长方体对象的精度</td></tr></tbody></table><h3 id="CubeSoure对象的常用方法"><a href="#CubeSoure对象的常用方法" class="headerlink" title="CubeSoure对象的常用方法"></a>CubeSoure对象的常用方法</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>set/get_x_length()</td><td>设置/获取长方体对象在x轴方向的长度</td></tr><tr><td>set/get_y_length()</td><td>设置/获取长方体对象在y轴方向的长度</td></tr><tr><td>set/get_z_length()</td><td>设置/获取长方体对象在z轴方向的长度</td></tr><tr><td>set/get_center()</td><td>设置/获取长方体对象所在坐标系的原点</td></tr><tr><td>set/get_bounds()</td><td>设置/获取长方体对象的包围盒</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h3 id="Tvtk库的基本三维对象"><a href="#Tvtk库的基本三维对象" class="headerlink" title="Tvtk库的基本三维对象"></a>Tvtk库的基本三维对象</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>CubeSource</td><td>立方体三维对象数据源</td></tr><tr><td>ConeSource</td><td>圆锥三维对象数据源</td></tr><tr><td>CylinderSource</td><td>圆柱三维对象数据源</td></tr><tr><td>ArcSource</td><td>圆弧三维对象数据源</td></tr><tr><td>ArrowSource</td><td>箭头三维对象数据源</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>示例</p><p><code>s = tvtk.ConeSource(height=3.0,radius=1.0,resolution=36)</code></p><h2 id="tvtk库显示一个三维对象"><a href="#tvtk库显示一个三维对象" class="headerlink" title="tvtk库显示一个三维对象"></a>tvtk库显示一个三维对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入tvtk库</span></span><br><span class="line"><span class="keyword">from</span> tvtk.api <span class="keyword">import</span> tvtk</span><br><span class="line"><span class="comment"># 创建一个长方体数据源，并且同时设置其长宽高</span></span><br><span class="line">s = tvtk.CubeSource(x_length = <span class="number">1.0</span>,y_length = <span class="number">2.0</span>,z_length = <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 转换为图形数据</span></span><br><span class="line">m = tvtk.PolyDataMapper(input_connection = s.output_port)</span><br><span class="line"><span class="comment"># 创建实体</span></span><br><span class="line">a = tvtk.Actor(mapper = m)</span><br><span class="line"><span class="comment"># 创建渲染器，将Actor添加进去</span></span><br><span class="line">r = tvtk.Renderer(background=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">r.add_actor(a)</span><br><span class="line"><span class="comment"># 创建一个窗口，将渲染器添加进去</span></span><br><span class="line">w = tvtk.RenderWindow(size=(<span class="number">300</span>,<span class="number">300</span>))</span><br><span class="line">w.add_renderer(r)</span><br><span class="line"><span class="comment"># 创建一个窗口的交互工具</span></span><br><span class="line">i = tvtk.RenderWindowInteractor(render_window=w)</span><br><span class="line">i.initialize()</span><br><span class="line">i.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;科学计算可视化的分类&quot;&gt;&lt;a href=&quot;#科学计算可视化的分类&quot; class=&quot;headerlink&quot; title=&quot;科学计算可视化的分类&quot;&gt;&lt;/a&gt;科学计算可视化的分类&lt;/h2&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.zhyat.cn/categories/Python/"/>
    
      <category term="Tvtk" scheme="http://blog.zhyat.cn/categories/Python/Tvtk/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhyat.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="三维可视化" scheme="http://blog.zhyat.cn/tags/%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>FCC 高级算法题之验证美国电话号码（Validate US Telephone Numbers）</title>
    <link href="http://blog.zhyat.cn/2017/11/30/FCC%20%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20-%20%E9%AA%8C%E8%AF%81%E7%BE%8E%E5%9B%BD%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/"/>
    <id>http://blog.zhyat.cn/2017/11/30/FCC 高级算法题 - 验证美国电话号码/</id>
    <published>2017-11-29T16:00:00.000Z</published>
    <updated>2019-02-19T03:35:59.966Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://freecodecamp.cn/challenges/validate-us-telephone-numbers" target="_blank" rel="noopener">题目描述</a></p><p>虽然这个题目是高级算法题，实际上是正则表达式的内容，先把正则表达式写出来。观察例子可以得出几个结论：</p><ul><li>电话号码为十位数字（不包括国家码，连接符）</li><li>国家码可以有也可以没有，有的时候只能为1</li><li>没有国家码时，如果电话号码没有连着写，则以334的形式分隔（如果有国家码，则以1334分组）</li><li>不包括国家码的第一组数字，可以用括号包围。</li><li><p>分隔符为空格或连接符，两者不能接连出现</p><a id="more"></a></li></ul><p>那么来逐一实现</p><p>第一步，实现十位数字连接出现和以334的形式出现</p><p>​    <code>\d{3}\d{3}\d{4}</code></p><p>第二步，实现国家码以1出现和不出现</p><p>​    <code>1?\d{3}\d{3}\d{4}</code></p><p>第三步，实现国家码之后可以有空格也可以无空格</p><p>​    <code>1? ?\d{3}\d{3}\d{4}</code></p><p><em>注意不要用 <code>/s</code>来匹配空格，因为<code>/s</code>匹配的是一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格</em></p><p>第四步，实现电话号码之间可以不分隔也可以用空格或连接符分隔</p><p>​    <code>1? ?\d{3}( |-)?\d{3}( |-)?\d{4}</code></p><p>第五步，实现第一组电话号码可以用括号包围，注意括号需要转义</p><p>​    <code>1? ?(\(\d{3}\)|\d{3})( |-)?\d{3}( |-)?\d{4}</code></p><p>第六步，为了保证匹配的是一串完整的号码，而不是某段数字的中间，匹配匹配输入开始和输入结束</p><p>​    <code>^1? ?(\(\d{3}\)|\d{3})( |-)?\d{3}( |-)?\d{4}$</code></p><p>正则表达式写完了，代码就很简单了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">telephoneCheck</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1?\s?(\(\d&#123;3&#125;\)|\d&#123;3&#125;)(\s|-)?\d&#123;3&#125;(\s|-)?\d&#123;4&#125;$/</span>.test(str);</span><br><span class="line">&#125;</span><br><span class="line">telephoneCheck(<span class="string">"555-555-5555"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://freecodecamp.cn/challenges/validate-us-telephone-numbers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目描述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然这个题目是高级算法题，实际上是正则表达式的内容，先把正则表达式写出来。观察例子可以得出几个结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电话号码为十位数字（不包括国家码，连接符）&lt;/li&gt;
&lt;li&gt;国家码可以有也可以没有，有的时候只能为1&lt;/li&gt;
&lt;li&gt;没有国家码时，如果电话号码没有连着写，则以334的形式分隔（如果有国家码，则以1334分组）&lt;/li&gt;
&lt;li&gt;不包括国家码的第一组数字，可以用括号包围。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分隔符为空格或连接符，两者不能接连出现&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Regexp" scheme="http://blog.zhyat.cn/categories/Regexp/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhyat.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="FreeCodeCamp" scheme="http://blog.zhyat.cn/tags/FreeCodeCamp/"/>
    
  </entry>
  
  <entry>
    <title>ECMScript 6 箭头函数</title>
    <link href="http://blog.zhyat.cn/2017/11/28/ECMAScript%206%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://blog.zhyat.cn/2017/11/28/ECMAScript 6 箭头函数/</id>
    <published>2017-11-27T16:00:00.000Z</published>
    <updated>2017-11-30T10:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 箭头函数是 ECMAScript 6 中引入的编写函数表达式的一种简便方法。</p><a id="more"></a><p>在 JavaScript 中创建一个函数通常有两种方式：</p><ul><li>函数语句</li><li>函数表达式</li></ul><p>但现在还可以使用箭头函数</p><p>用函数语句创建一个函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,mum2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = num1 + num2;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但现在用函数表达式只需要一行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">num1,num2</span>) =&gt;</span> &#123;<span class="keyword">return</span> num1 + num2;&#125;;</span><br></pre></td></tr></table></figure><h3 id="基本语法规则"><a href="#基本语法规则" class="headerlink" title="基本语法规则"></a>基本语法规则</h3><h4 id="多参数传递"><a href="#多参数传递" class="headerlink" title="多参数传递"></a>多参数传递</h4><p>多个参数应该在小括号中传递，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">num1,num2,num3</span>) =&gt;</span> &#123;<span class="keyword">return</span> num1 + num2 + num3;&#125;;</span><br></pre></td></tr></table></figure><p>只传递一个函数的时候，小括号可以省略，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mul = <span class="function"><span class="params">num</span> =&gt;</span> &#123;<span class="keyword">return</span> num * <span class="number">666</span>;&#125;;</span><br></pre></td></tr></table></figure><p>不传递参数的时候，小括号不可以省略，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(<span class="string">"hello word"</span>)&#125;;</span><br></pre></td></tr></table></figure><ul><li>函数主体括号可选</li><li>return 语句可选</li></ul><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>箭头函数支持 ES6 的默认参数功能，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">num1=<span class="number">1</span>,num2=<span class="number">2</span></span>) =&gt;</span> num1 + num2;</span><br></pre></td></tr></table></figure><h4 id="返回对象字面量"><a href="#返回对象字面量" class="headerlink" title="返回对象字面量"></a>返回对象字面量</h4><p>如果要使用箭头函数返回对象字面量，需要把返回对象装入小括号中，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student = <span class="function">(<span class="params">name,age</span>) =&gt;</span>(&#123;</span><br><span class="line">  name:name,</span><br><span class="line">  age:age</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="this值"><a href="#this值" class="headerlink" title="this值"></a>this值</h4><p>箭头函数不会创建自己的<code>this</code>,它使用封闭上下文的<code>this</code>值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.age++; <span class="comment">// |this| properly refers to the person object</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>所以在这段代码中，传递给<code>setInterval</code>的函数内的<code>this</code>与封闭函数中的<code>this</code>值相同</p><h3 id="使用箭头函数的注意事项"><a href="#使用箭头函数的注意事项" class="headerlink" title="使用箭头函数的注意事项"></a>使用箭头函数的注意事项</h3><h4 id="不能使用箭头函数作为构造函数，如下；"><a href="#不能使用箭头函数作为构造函数，如下；" class="headerlink" title="不能使用箭头函数作为构造函数，如下；"></a>不能使用箭头函数作为构造函数，如下；</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123; name = name, age = age &#125;;</span><br><span class="line"><span class="keyword">var</span> jack = <span class="keyword">new</span> Student(<span class="string">"Jack"</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><img src="//blog.zhyat.cn/2017/11/28/ECMAScript 6 箭头函数/2017-11-29_抛出异常.jpg" alt="抛出异常"></p><h4 id="箭头函数没有原型"><a href="#箭头函数没有原型" class="headerlink" title="箭头函数没有原型"></a>箭头函数没有原型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = <span class="function">(<span class="params">name, age</span>) =&gt;</span> &#123; name = name, age = age &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype)</span><br></pre></td></tr></table></figure><p><img src="//blog.zhyat.cn/2017/11/28/ECMAScript 6 箭头函数/2017-11-29_没有原型.jpg" alt="没有原型"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 箭头函数是 ECMAScript 6 中引入的编写函数表达式的一种简便方法。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ECMScript 6" scheme="http://blog.zhyat.cn/categories/%E5%89%8D%E7%AB%AF/ECMScript-6/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhyat.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何看懂铁路图（语法图）</title>
    <link href="http://blog.zhyat.cn/2017/10/28/%E7%9C%8B%E6%87%82%E9%93%81%E8%B7%AF%E5%9B%BE(%E8%AF%AD%E6%B3%95%E5%9B%BE)/"/>
    <id>http://blog.zhyat.cn/2017/10/28/看懂铁路图(语法图)/</id>
    <published>2017-10-28T00:29:00.000Z</published>
    <updated>2017-11-05T08:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>语法图（Syntax diagrams ）又叫铁路图（railroad diagrams）是描述形式文法的一种方式。它是巴科斯范式或扩展巴科斯范式的图形化表示。最早使用语法图的书包括Niklaus Wirth写的“Pascal User Manual”（语法图开始于47页）和the Burroughs CANDE manual。在编译领域，像BNF和它的变体这样的文字式表示法都是首选的。BNF能很好的被编译器作者和编译器理解，但是不能很好的被这些语言的大部分用户理解。铁路图能更容易被大多数人理解。数据交换格式JSON之所以流行的部分原因就是它用铁路图来表示。 </p><p>–《维基百科》</p></blockquote><a id="more"></a><h2 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h2><blockquote><ol><li>从左边界开始沿着轨道去到右边界。</li><li>沿途，你将在圆框中遇到的是字面量，在方块中遇到的是规则或者描述。</li><li>任何沿着轨道能走通的序列都是合法的。</li><li>任何不能沿着轨道走通的序列都是非法的。</li><li>每个末端只有一个竖条的铁路图允许在任何一对标记中间插入空白。而在末端有两个竖条的铁路图是不允许的。</li></ol></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以《JavaScript语言精粹》第10页的铁路图为例：</p><p><img src="//blog.zhyat.cn/2017/10/28/看懂铁路图(语法图)/2017-11-05_statements.jpg" alt="语句铁路图"></p><p>一条JavaScript语句可以是：</p><ol><li><code>var name = expression;</code></li><li><code>var name1,name2,name3...,name;</code></li><li><code>var name 1,name2,...name3=expression3,...,name=expression;</code></li><li><code>var name 1,name2,...name3=expression3,...,name;</code></li><li><code>var name1=expression1,name2=expression2,name3=expression3...,name=expression;</code></li></ol><hr><p>参考资料</p><p><a href="https://en.wikipedia.org/wiki/Syntax_diagram" target="_blank" rel="noopener">wikipedia Syntax diagram</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;语法图（Syntax diagrams ）又叫铁路图（railroad diagrams）是描述形式文法的一种方式。它是巴科斯范式或扩展巴科斯范式的图形化表示。最早使用语法图的书包括Niklaus Wirth写的“Pascal User Manual”（语法图开始于47页）和the Burroughs CANDE manual。在编译领域，像BNF和它的变体这样的文字式表示法都是首选的。BNF能很好的被编译器作者和编译器理解，但是不能很好的被这些语言的大部分用户理解。铁路图能更容易被大多数人理解。数据交换格式JSON之所以流行的部分原因就是它用铁路图来表示。 &lt;/p&gt;
&lt;p&gt;–《维基百科》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编译原理" scheme="http://blog.zhyat.cn/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="学习笔记" scheme="http://blog.zhyat.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
