<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhyat Blog</title>
  
  <subtitle>学而思之</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zhyat.cn/"/>
  <updated>2020-02-13T09:56:08.470Z</updated>
  <id>http://blog.zhyat.cn/</id>
  
  <author>
    <name>zhyat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见的改善前端代码的设计模式-策略模式</title>
    <link href="http://blog.zhyat.cn/2020/02/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zhyat.cn/2020/02/13/设计模式之策略模式/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2020-02-13T09:56:08.470Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>定义：定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换。<br>使用场景：达到某个目的，有不同的方法。例如表单校验。<br>关键：环境类（context)接受某一请求，随后把某一请求委托给一策略类，context需要维持对某一策略对象的引用。<br>名词解释：环境类：接受客户请求的类；策略类：实现具体算法的类</p><h2 id="模仿面向对象语言的代码实现"><a href="#模仿面向对象语言的代码实现" class="headerlink" title="模仿面向对象语言的代码实现"></a>模仿面向对象语言的代码实现</h2><p><em>jscode</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略类</span></span><br><span class="line"><span class="keyword">var</span> muneA = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">muneA.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count * <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> muneB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">muneB.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count * <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> muneC = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">muneC.prototype.calculate = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count * <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境类</span></span><br><span class="line"><span class="keyword">var</span> Checkstand = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.count = <span class="literal">null</span></span><br><span class="line"><span class="keyword">this</span>.strategy = nul;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Checkstand.prototype.setCount = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.count = count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Checkstand.prototype.setStrategy = <span class="function"><span class="keyword">function</span> (<span class="params">strategy</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.strategy = strategy</span><br><span class="line">&#125;</span><br><span class="line">Checkstand.prototype.getDealMoney = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.strategy.calculate(<span class="keyword">this</span>.strategy)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> checkstand = <span class="keyword">new</span> Checkstand()</span><br><span class="line">checkstand.setStrategy(<span class="keyword">new</span> muneA()) <span class="comment">// 设置策略对象</span></span><br><span class="line">checkstand.setCount(<span class="number">10</span>)  <span class="comment">// 设置数量</span></span><br></pre></td></tr></table></figure></p><h2 id="根据js语言特性的代码实现"><a href="#根据js语言特性的代码实现" class="headerlink" title="根据js语言特性的代码实现"></a>根据js语言特性的代码实现</h2><p><em>jscode</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strategy = &#123;</span><br><span class="line"><span class="string">"muneA"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count * <span class="number">100</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"muneB"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count * <span class="number">1000</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"muneC"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count * <span class="number">500</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">var</span> calculateDelaMoney = <span class="function"><span class="keyword">function</span> (<span class="params">menuType, count</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> strategy[menuType](count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;定义：定义一系列的算法, 把它们一个个封装起来, 并且使它们可以相互替换。&lt;br&gt;使用场景：达到某个目的，有不同的方法。例如
      
    
    </summary>
    
      <category term="设计模式｜Design Pattern" scheme="http://blog.zhyat.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BD%9CDesign-Pattern/"/>
    
    
      <category term="FrontEnd" scheme="http://blog.zhyat.cn/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>常见的改善前端代码的设计模式-代理模式</title>
    <link href="http://blog.zhyat.cn/2020/02/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zhyat.cn/2020/02/13/设计模式之代理模式/</id>
    <published>2020-02-12T16:00:00.000Z</published>
    <updated>2020-02-13T09:57:57.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>定义：为一个对象提供一个代用品或占位符，以便控制对它的访问</p><p>场景：权限控制（保护代理）、延迟加载（虚拟代理）、缓存代理</p><p>代理的意义：维护单一职责原则</p><p>代理和本体接口应该有一致性，这样的好处是：</p><ul><li>用户可以放心地请求代理，他只关系是否能够得到想要的结果</li><li>在任何使用本体的地方都可以替换成使用代理</li></ul><h2 id="虚拟代理的代码实现"><a href="#虚拟代理的代码实现" class="headerlink" title="虚拟代理的代码实现"></a>虚拟代理的代码实现</h2><p><em>jscode</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">** 图片预加载，代理在图片加载之前显示一个loading</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line"><span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement( <span class="string">'img'</span> );     </span><br><span class="line"><span class="built_in">document</span>.body.appendChild( imgNode );      </span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;         </span><br><span class="line">imgNode.src = src;     </span><br><span class="line">&#125; </span><br><span class="line">&#125;)();  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;     </span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image;      </span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;         </span><br><span class="line">  myImage( <span class="keyword">this</span>.src );     </span><br><span class="line">&#125;      </span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> src </span>)</span>&#123;        </span><br><span class="line">myImage( <span class="string">'file:// /C:/Users/svenzeng/Desktop/loading.gif'</span> );         </span><br><span class="line">img.src = src;        </span><br><span class="line">&#125; </span><br><span class="line">&#125;)();  </span><br><span class="line"></span><br><span class="line">proxyImage( <span class="string">'http:// imgcache.qq.com/music// N/k/000GGDys0yA0Nk.jpg'</span> );</span><br></pre></td></tr></table></figure></p><h2 id="缓存代理的代码实现"><a href="#缓存代理的代码实现" class="headerlink" title="缓存代理的代码实现"></a>缓存代理的代码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++ ) &#123;</span><br><span class="line">a = a * <span class="built_in">arguments</span>[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> plus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++ ) &#123;</span><br><span class="line">a = a + <span class="built_in">arguments</span>[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓存代理的工厂</span></span><br><span class="line"><span class="keyword">var</span> createProxyFactory = <span class="function"><span class="keyword">function</span>(<span class="params"> fn </span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.join.call( <span class="built_in">arguments</span>. <span class="string">','</span>);</span><br><span class="line"><span class="keyword">if</span>( args <span class="keyword">in</span> cache ) &#123; </span><br><span class="line"><span class="keyword">return</span> cache[ args ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cache[ args ] = fn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> proxyMult = createProxyFactory( mult ), </span><br><span class="line">proxyPlus = createProxyFactory( plus )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;定义：为一个对象提供一个代用品或占位符，以便控制对它的访问&lt;/p&gt;
&lt;p&gt;场景：权限控制（保护代理）、延迟加载（虚拟代理）、
      
    
    </summary>
    
      <category term="设计模式｜Design Pattern" scheme="http://blog.zhyat.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BD%9CDesign-Pattern/"/>
    
    
      <category term="FrontEnd" scheme="http://blog.zhyat.cn/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序路由栈不能超过 10 的解决方案</title>
    <link href="http://blog.zhyat.cn/2019/09/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B7%AF%E7%94%B1%E6%A0%88%E4%B8%8D%E8%83%BD%E8%B6%85%E8%BF%8710%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.zhyat.cn/2019/09/09/小程序路由栈不能超过10的解决方案/</id>
    <published>2019-09-08T16:00:00.000Z</published>
    <updated>2020-02-12T07:00:00.673Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序路由跳转有个隐藏的坑，就是 <code>wx.navigateTo</code>打开新页面，最多只能打开10个，超过10个之后就没反应，控制台也不会报错。<br><a id="more"></a></p><h2 id="方案一：最粗暴…navigateTo不行，那就redirectTo"><a href="#方案一：最粗暴…navigateTo不行，那就redirectTo" class="headerlink" title="方案一：最粗暴…navigateTo不行，那就redirectTo"></a>方案一：最粗暴…<code>navigateTo</code>不行，那就<code>redirectTo</code></h2><p>小程序路由跳转的方式有五种，分别是<code>wx.navigateTo</code>（打开新页面，新页面入栈）、<code>wx.redirectTo</code>（重定向，当前页面出栈，新页面入栈）、<code>wx.navigateBack</code>（返回，页面不断出栈，直到目标返回页）、<code>wx.switchTab</code>（切换tab页面，页面全部出栈，只留下新的 Tab 页面）、<code>wx.reLaunch</code>（页面全部出栈，只留下新的页面）</p><p>由此产生了第一种方式，当页面栈超过 10 时，直接用<code>redirectTo</code>。</p><p>但这样太粗暴了，显然很多场景是需要保留访问过的页面的，由此有了方案一的升级版。</p><h2 id="方案一升级版：根据页面栈决定当前跳转方式"><a href="#方案一升级版：根据页面栈决定当前跳转方式" class="headerlink" title="方案一升级版：根据页面栈决定当前跳转方式"></a>方案一升级版：根据页面栈决定当前跳转方式</h2><p>每次跳转先去页面栈中查找目标页面是否已经访问过，如果访问过则用<code>wx.navigateBack</code>返回，如果没有访问过则判断页面栈中是否已经有10个页面，有则用<code>wx.redirectTo</code>，没有则<code>navigateTo</code><br> <em>js code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteMp</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(opt=&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.MAX_DEEP = opt.MAX_DEEP || <span class="number">10</span></span><br><span class="line">    <span class="keyword">this</span>.IS_AUTO_BACK = opt.IS_AUTO_BACK || <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.PAGE_STACk = getCurrentPages()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _findPageInHistory(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; PAGE_STACk &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> delta = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; PAGE_STACk.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PAGE_STACk[i].route === path) &#123;</span><br><span class="line">        delta = i + <span class="number">1</span> <span class="comment">// 目标页在栈中的位置</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delta</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _dataToUrlQuery(data=&#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> query = <span class="string">'?'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(prop)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = data[prop];</span><br><span class="line">        query += <span class="string">`<span class="subst">$&#123;prop&#125;</span>=<span class="subst">$&#123;value&#125;</span>&amp;`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> query.replace(<span class="regexp">/&amp;$/</span>, <span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  goPage(opt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!opt) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'缺少参数'</span>)</span><br><span class="line">    <span class="keyword">if</span> (opt &amp;&amp; !opt.path) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'缺少跳转目标path'</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; PAGE_STACk &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> pageStackLen = PAGE_STACk.length</span><br><span class="line">    <span class="keyword">let</span> &#123; path, data &#125; = opt</span><br><span class="line">    <span class="keyword">let</span> delta = <span class="keyword">this</span>._findPageInHistory(path)</span><br><span class="line">    path = <span class="string">'/'</span> + path.replace(<span class="regexp">/^\//</span>, <span class="string">''</span>) + <span class="keyword">this</span>._dataToUrlQuery(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delta &gt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>.IS_AUTO_BACK) &#123;</span><br><span class="line">      <span class="comment">// 如果有目标页已经是被访问过的</span></span><br><span class="line">      <span class="keyword">const</span> backPage = PAGE_STACk[pageStackLen - delta]</span><br><span class="line">      backPage.setData(&#123;data&#125;);</span><br><span class="line">      wx.navigateBack(&#123;</span><br><span class="line">        delta: pageStackLen - delta</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (pageStackLen &lt; <span class="keyword">this</span>.MAX_DEEP) &#123;</span><br><span class="line">        wx.navigateTo(&#123;</span><br><span class="line">          url: path</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wx.redirectTo(&#123;</span><br><span class="line">          url: path</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = RouteMp</span><br></pre></td></tr></table></figure></p><p>但是这样依然有问题，页面传参数变得无法统一，而且明明是前进页面，用户使用的时候很可能看着就是返回了几个页面。</p><h2 id="方案二：在小程序页面栈之外维护多一个自己的逻辑栈"><a href="#方案二：在小程序页面栈之外维护多一个自己的逻辑栈" class="headerlink" title="方案二：在小程序页面栈之外维护多一个自己的逻辑栈"></a>方案二：在小程序页面栈之外维护多一个自己的逻辑栈</h2><p>这个方案并非我们自己想到的，出处是某位清华学霸，我是在<a href="https://juejin.im/post/5c09d82e51882517165dd485" target="_blank" rel="noopener">掘金-小程序无限层级路由方案</a>看到的。</p><p>总的来说就是：</p><ol><li>9层（含9层）以内时：走小程序自己的历史栈就ok了，跳转时候更新一下逻辑栈，这没啥可说的</li><li>从9层跳转10层：需要把第9层重定向到中转页，再由中转页跳转到10层</li><li>10层以后跳转：在navigateTo方法中处理，到10层之后，再跳转就第10层页面一直做redirectTo（重定向）操作了</li><li>10层以上返回：会返回到中转页，由中转页判断，具体返回到哪个页面，然后navigateTo（跳转）过去</li><li>从10层返回到9层：返回到中转页，将中转页redirectTo（重定向）到第9层页面</li><li>9层内的返回：直接返回就好了，返回时候不会更新逻辑栈，但没有关系，因为只有中转页才会用到逻辑栈</li><li>逻辑栈更新机制：<ul><li>跳转、返回中转页时更新<ul><li>navigateTo时更新</li><li>redirectTo时更新</li><li>reLaunch时更新</li><li>navigateBack时更新</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信小程序路由跳转有个隐藏的坑，就是 &lt;code&gt;wx.navigateTo&lt;/code&gt;打开新页面，最多只能打开10个，超过10个之后就没反应，控制台也不会报错。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
      <category term="领域语言" scheme="http://blog.zhyat.cn/tags/%E9%A2%86%E5%9F%9F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>常见的改善前端代码的设计模式-单例模式</title>
    <link href="http://blog.zhyat.cn/2019/08/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.zhyat.cn/2019/08/31/设计模式之单例模式/</id>
    <published>2019-08-31T09:16:35.332Z</published>
    <updated>2020-02-13T08:25:45.776Z</updated>
    
    <content type="html"><![CDATA[<p>前端相对于后端，对于设计模式的理解和主动使用是欠缺的，更多的时候是凭借着经验使用到了，却缺乏对此的理解和认知。</p><p>所谓设计模式，就是对一些代码的总结和归纳，使得建立良好的代码有迹可循，知道什么场景怎么去写，这样写有什么样的好处和弊端。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>定义：保证一个类仅有一个实例,并提供一个访问它的全局访问点。<br>使用场景：全局缓存、Windows对象、登录浮窗等<br>关键：用一个变量来标志是否已经为某个类创建对象，没有则创建，有则返回这个对象</p><h2 id="标准单例模式"><a href="#标准单例模式" class="headerlink" title="标准单例模式"></a>标准单例模式</h2><p>代码实现：<br><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标准单例模式</span></span><br><span class="line"><span class="comment"> * 缺点是使用者必须知道这是个单例类，本来可以直接new xxx，现在变成了xxx.getInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.instance = <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line">Singleton.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">Singleton.prototype.getInstance = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.instance!==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="透明单例模式"><a href="#透明单例模式" class="headerlink" title="透明单例模式"></a>透明单例模式</h2><p><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用闭包和IIFE实现了透明单例模式</span></span><br><span class="line"><span class="comment"> * 但违反了单一职责原则</span></span><br><span class="line"><span class="comment"> * 缺点是，当不再需要单例时，需要改写构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> CreateDiv = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance</span><br><span class="line">  <span class="keyword">var</span> CreateDiv = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.html = html</span><br><span class="line">    <span class="keyword">this</span>.init() <span class="comment">// 执行init方法</span></span><br><span class="line">    <span class="keyword">return</span> (instance = <span class="keyword">this</span>) <span class="comment">// 保证只有一个一个对象</span></span><br><span class="line">  &#125;</span><br><span class="line">  CreateDiv.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    div.innerHTML = <span class="keyword">this</span>.html</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> CreateDiv</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><h2 id="用代理实现的单例"><a href="#用代理实现的单例" class="headerlink" title="用代理实现的单例"></a>用代理实现的单例</h2><p><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理实现单例</span></span><br><span class="line"><span class="comment"> * 将负责管理单例的逻辑移到proxySingletonCreate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> CreateSpan = <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.html = html</span><br><span class="line">  <span class="keyword">this</span>.init()</span><br><span class="line">&#125;</span><br><span class="line">CreateSpan.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>)</span><br><span class="line">  span.innerHTML = <span class="keyword">this</span>.html</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(span)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxySingletonCreate = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) [(instance = <span class="keyword">new</span> CreateSpan(<span class="string">'test'</span>))]</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><h2 id="创建单例的通用方法"><a href="#创建单例的通用方法" class="headerlink" title="创建单例的通用方法"></a>创建单例的通用方法</h2><p>由上可以看出，创建单例的核心即为使用一个变量表示这个对象是否被创建，即：<br><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance</span><br><span class="line"><span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">   instance = xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体代码实现即为：<br><em>javascript code</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建单例的抽象方法</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; fn </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端相对于后端，对于设计模式的理解和主动使用是欠缺的，更多的时候是凭借着经验使用到了，却缺乏对此的理解和认知。&lt;/p&gt;
&lt;p&gt;所谓设计模式，就是对一些代码的总结和归纳，使得建立良好的代码有迹可循，知道什么场景怎么去写，这样写有什么样的好处和弊端。&lt;/p&gt;
&lt;h2 id=&quot;基
      
    
    </summary>
    
      <category term="设计模式｜Design Pattern" scheme="http://blog.zhyat.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BD%9CDesign-Pattern/"/>
    
    
      <category term="FrontEnd" scheme="http://blog.zhyat.cn/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>设计稿中字体对应的字重</title>
    <link href="http://blog.zhyat.cn/2019/07/10/%E5%AD%97%E4%BD%93%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E9%87%8D/"/>
    <id>http://blog.zhyat.cn/2019/07/10/字体对应的字重/</id>
    <published>2019-07-09T19:21:55.464Z</published>
    <updated>2020-02-12T06:53:52.571Z</updated>
    
    <content type="html"><![CDATA[<p>设计师给的标注文件经常会出现一个情况，字重总是通过直接设置具体的字体来指定字重，实际上在font-family那一行Medium指的是字重。<br><img src="/2019/07/10/字体对应的字重/exp1.png" title="例子"></p><p>其对应关系大致符合：<br>100 - Thin<br>200 - Extra Light (Ultra Light)<br>300 - Light<br>400 - Regular (Normal、Book、Roman)<br>500 - Medium<br>600 - Semi Bold (Demi Bold)<br>700 - Bold<br>800 - Extra Bold (Ultra Bold)<br>900 - Black (Heavy)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计师给的标注文件经常会出现一个情况，字重总是通过直接设置具体的字体来指定字重，实际上在font-family那一行Medium指的是字重。&lt;br&gt;&lt;img src=&quot;/2019/07/10/字体对应的字重/exp1.png&quot; title=&quot;例子&quot;&gt;&lt;/p&gt;
&lt;p&gt;其对应关
      
    
    </summary>
    
      <category term="CSS" scheme="http://blog.zhyat.cn/categories/CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6 之 Symbol</title>
    <link href="http://blog.zhyat.cn/2019/06/02/ES6-Symbol/"/>
    <id>http://blog.zhyat.cn/2019/06/02/ES6-Symbol/</id>
    <published>2019-06-01T22:39:12.266Z</published>
    <updated>2020-02-13T09:52:53.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Symbol 的用法其实很简单，就是创建一个独一无二的值。<br>举个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>() == <span class="built_in">Symbol</span>() <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><img src="/2019/06/02/ES6-Symbol/Symbol_not_equal.png" title="Symbol()之间不相等"><p>需要注意的是，不能使用 <code>new</code> 创建 <code>Symbol</code> ，因为 <code>Symbol</code> 是一个基本类型。</p><p>通常在使用 <code>Symbol</code> 的时候，会在其中加入标识符，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// Symbol(foo)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>) == <span class="built_in">Symbol</span>(<span class="string">'foo'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>).toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'foo'</span>).toString() === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>).toString() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><img src="/2019/06/02/ES6-Symbol/Symbol_exp1.png" title="Symbol()的一些情况"><p><code>Symbol</code> 有 <code>toString()</code> 方法</p><h2 id="主要使用场景"><a href="#主要使用场景" class="headerlink" title="主要使用场景"></a>主要使用场景</h2><h3 id="作为对象的属性名"><a href="#作为对象的属性名" class="headerlink" title="作为对象的属性名"></a>作为对象的属性名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line">o[mySymbol] = <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><p>需要注意的是，使用 <code>Symbol</code> 作为属性名时，要用 <code>[]</code> 的方式访问，因为点符号后面跟的只能时字符串。</p><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>保证这些常量不相等<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = &#123;&#125;</span><br><span class="line">log.levels = &#123;</span><br><span class="line">  DEBUG: <span class="built_in">Symbol</span>(<span class="string">'debug'</span>),</span><br><span class="line">  INFO: <span class="built_in">Symbol</span>(<span class="string">'info'</span>),</span><br><span class="line">  WARN: <span class="built_in">Symbol</span>(<span class="string">'warn'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.DEBUG, <span class="string">'debug message'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(log.levels.INFO, <span class="string">'info message'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="保证-Switch-按照设计使用"><a href="#保证-Switch-按照设计使用" class="headerlink" title="保证 Switch 按照设计使用"></a>保证 Switch 按照设计使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> COLOR_RED    = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> COLOR_GREEN  = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> COLOR_RED:</span><br><span class="line">      <span class="keyword">return</span> COLOR_GREEN;</span><br><span class="line">    <span class="keyword">case</span> COLOR_GREEN:</span><br><span class="line">      <span class="keyword">return</span> COLOR_RED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Symbol 还有一些其他方法，请参阅读<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener">MDN Web Docs</a></p><p>不过需要特别注意的是，Symbol 定义的属性名，在使用 <code>for...in</code> 、<code>for...of</code> 等需要有迭代器的方法时不会出现，要获得一个对象所有的<code>Symbol</code> 属性名可以使用 <code>Object.getOwnPropertySymbols()</code> 方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;Symbol 的用法其实很简单，就是创建一个独一无二的值。&lt;br&gt;举个例子：&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
      <category term="ECMAScript 6" scheme="http://blog.zhyat.cn/categories/JavaScript/ECMAScript-6/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 中判断 this 指向的一些方法</title>
    <link href="http://blog.zhyat.cn/2019/05/27/JavaScript%E4%B8%AD%E5%88%A4%E6%96%ADthis%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.zhyat.cn/2019/05/27/JavaScript中判断this指向的一些方法/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2020-02-12T06:34:50.698Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 中的 this 可能是 JS 这门语言中最难的一个关键字，想要去理解 this 运作的原理对 JS 需要一定的使用经验。本文并不深究 this 为什么指向某个地方，本文是一篇方法论的文章，只说明怎么样判断 this 的指向。</p><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><ol><li>this 指向自身 ❌</li><li>this 指向函数的作用域 ❌</li></ol><h3 id="正确的说法"><a href="#正确的说法" class="headerlink" title="正确的说法"></a>正确的说法</h3><blockquote><p>this 实际上是发生在函数调用时候的绑定，它指向什么完全取决于函数在哪里调用</p></blockquote><p>看得明明白白，好像自己真的懂了是不是？呵呵，不可能的。</p><h3 id="绑定的几条规则"><a href="#绑定的几条规则" class="headerlink" title="绑定的几条规则"></a>绑定的几条规则</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>独立函数调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>f()没有加任何的修饰的函数引用，所以此函数不可能使用其他规则，进而 this 此时指向的就是全局对象。不过需要注意的是，在严格模式中，this 是不可以绑定到全局对象上的。</p><p>这条规则就是，别的规则都不生效，那就是这条规则。</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>当调用位置有上下文对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a:<span class="number">1</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.foo() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但是这条规则有几个需要注意的场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a:<span class="number">1</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fCopy = o.foo <span class="comment">// 别名</span></span><br><span class="line">fCopy() <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure><p>为什么会出现这种情况呢？因为实际上<code>fCopy</code> 是 <code>foo</code> 的引用, 是一个没有修饰符，即没有上下文对象的函数调用。</p><h4 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h4><p>使用 <code>call</code> 和 <code>apply()</code> 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">f.call(o)</span><br></pre></td></tr></table></figure></p><p>这个很明显了，就是手动的明确的，将f的this指向绑定到o上。</p><h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">f.a <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>js 的 new 实际上不是面向对象如java那种创建一个对象的实例，它是基于原型关系的。</p><p>先创建了一个对象，然后连接到到原型上。关于这一块，可以参考 JavaScript 实现复用那篇文章。</p><h3 id="优先级别"><a href="#优先级别" class="headerlink" title="优先级别"></a>优先级别</h3><p>new &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2019/05/27/JavaScript中判断this指向的一些方法/this_flow.png" title="this指向的流程图">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript 中的 this 可能是 JS 这门语言中最难的一个关键字，想要去理解 this 运作的原理对 JS 需要一定的使用经验。本文并不深究 this 为什么指向某个地方，本文是一篇方法论的文章，只说明怎么样判断 this 的指向。&lt;/p&gt;
&lt;h3 id=&quot;误
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>每日一道大厂题-HTTPS握手</title>
    <link href="http://blog.zhyat.cn/2019/03/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%81%93%E5%A4%A7%E5%8E%82%E9%A2%98-HTTPS%E6%8F%A1%E6%89%8B/"/>
    <id>http://blog.zhyat.cn/2019/03/29/每日一道大厂题-HTTPS握手/</id>
    <published>2019-03-28T20:20:20.921Z</published>
    <updated>2020-02-12T06:53:18.607Z</updated>
    
    <content type="html"><![CDATA[<p><strong>来自<a href="https://github.com/Advanced-Frontend/Daily-Interview-Question" target="_blank" rel="noopener">Daily-Interview-Question</a></strong></p><p>Q：介绍 HTTPS 握手过程</p><ol><li>Client Hello</li><li>Server Hello</li><li>Certificate</li><li>Server Hello Done</li><li>Client Key Exchange</li><li>Change Cipher Spec</li><li>Finished</li><li>Change Cipher Spec</li><li>Finished</li></ol><h3 id="步骤一：客户端发送请求（Client-Hello）"><a href="#步骤一：客户端发送请求（Client-Hello）" class="headerlink" title="步骤一：客户端发送请求（Client Hello）"></a>步骤一：客户端发送请求（Client Hello）</h3><p>首先，客户端向服务端提供加密信息的通信。</p><ol><li>客户端支持的SSL的指定版本</li><li>客户端产生的随机数（Client Random, 稍后用于生成”对话密钥”</li><li>客户端支持的加密算法</li></ol><h3 id="步骤二：服务器回应（Sever-Hello）"><a href="#步骤二：服务器回应（Sever-Hello）" class="headerlink" title="步骤二：服务器回应（Sever Hello）"></a>步骤二：服务器回应（Sever Hello）</h3><p>服务端收到请求，向客户端发出回应</p><ol><li>确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</li><li>一个服务器生成的随机数(Server Random)，稍后用于生成”对话密钥”。</li><li>确认使用的加密方法，比如RSA公钥加密。</li><li>服务器证书</li></ol><p><em>第一次握手结束</em></p><h3 id="步骤三：发送验证消息"><a href="#步骤三：发送验证消息" class="headerlink" title="步骤三：发送验证消息"></a>步骤三：发送验证消息</h3><p>SSL服务器将数字证书通过Certificate消息发送给SSL客户端，证书里面包含了网站地址，加密公钥，以及证书的颁发机构。</p><h3 id="步骤四：服务器回应结束"><a href="#步骤四：服务器回应结束" class="headerlink" title="步骤四：服务器回应结束"></a>步骤四：服务器回应结束</h3><p>SSL服务器发送Server Hello Done消息，通知SSL客户端版本和加密套件协商结束，开始进行密钥交换。</p><h3 id="步骤五："><a href="#步骤五：" class="headerlink" title="步骤五："></a>步骤五：</h3><p>SSL客户端验证SSL服务器的证书合法后，如果不合法浏览器会提示。如果合法的话，利用证书中的公钥，SSL客户端随机生成的premaster secret（后续加密数据所需要的对称密钥），并通过Client Key Exchange消息发送给SSL服务器。</p><p><em>第二次握手结束</em></p><h3 id="步骤六："><a href="#步骤六：" class="headerlink" title="步骤六："></a>步骤六：</h3><p>SSL客户端发送Change Cipher Spec消息，通知SSL服务器后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。</p><h3 id="步骤七："><a href="#步骤七：" class="headerlink" title="步骤七："></a>步骤七：</h3><p>SSL客户端计算已交互的握手消息（除Change Cipher Spec消息外所有已交互的消息）的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL服务器。SSL服务器利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。</p><h3 id="步骤八："><a href="#步骤八：" class="headerlink" title="步骤八："></a>步骤八：</h3><p>同样地，SSL服务器发送Change Cipher Spec消息，通知SSL客户端后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。</p><h3 id="步骤九："><a href="#步骤九：" class="headerlink" title="步骤九："></a>步骤九：</h3><p>SSL服务器计算已交互的握手消息的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL客户端。SSL客户端利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。</p><p><em>第三次握手结束</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;来自&lt;a href=&quot;https://github.com/Advanced-Frontend/Daily-Interview-Question&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Daily-Interview-Question
      
    
    </summary>
    
      <category term="网络｜Network" scheme="http://blog.zhyat.cn/categories/%E7%BD%91%E7%BB%9C%EF%BD%9CNetwork/"/>
    
    
      <category term="面试" scheme="http://blog.zhyat.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript问答</title>
    <link href="http://blog.zhyat.cn/2019/03/29/JavaScript%E9%97%AE%E7%AD%94/"/>
    <id>http://blog.zhyat.cn/2019/03/29/JavaScript问答/</id>
    <published>2019-03-28T19:32:44.976Z</published>
    <updated>2019-06-02T07:16:08.003Z</updated>
    
    <content type="html"><![CDATA[<p>Q：为什么有的编程规范要求用void 0 代替 undefined?<br>A: undefined 是一个全局变量，可以被修改。为了准备的表达“未定义”，所以使用void 0</p><p>Q：underfined 与 null 的区别？<br>A：underfined 是Underfined类型的一个值，是一个名为underfined的变量，表达的意思是“从未赋值”“从未定义”，而null是Nulll类型的一个值，是JavaSript语言的关键字，表达的意思是“定义了但是为空”</p><p>Q：0.1+0.2 不能 = 0.3？怎么比较浮点数？<br>A：Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON，浮点数的特性决定了等式两边相差了微小的值，应该比较等式两边之差是否小于最小精度值</p><p>Q：为什么parseInt推荐传入第二个参数？<br>A：在不传入第二个参数的时候，parseInt默认转换0x开头的16进制，还支持0开头的八进制，所以推荐在任何时候都传入第二个参数。parseFloat则直接把字符串作为十进制解析。多数情况下，Number是比parseInt和parseFloat更好的选择。</p><p>Q：instanceof、typeof 和 Object.prototype.toString的区别？<br>Q：[‘1’,’2’,’3’].map(parseInt)的结果？</p><p>Q: 一个页面如果有一万个Bottom如何绑定事件？<br>A：事件委托，绑定父节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.list'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">// 绑定事件到父节点</span></span><br><span class="line">    <span class="built_in">console</span>.log($(event.target).html()); <span class="comment">// 注意操作对象是event.target还是this，下面会有详细说明哦</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'.list'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.target.tagName === <span class="string">'LI'</span>) &#123; <span class="comment">// 判断标签是不是li，注意tagName属性返回的是大写</span></span><br><span class="line">        <span class="built_in">console</span>.log($(event.target).html());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Q: 我们现在要实现一个红绿灯，把一个圆形 div 绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色<br>A:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">        setTimeout(resolve, duration);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params">duration,color</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"traffic-light"</span>).style.background = color;</span><br><span class="line">    <span class="keyword">await</span> sleep(duration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">await</span> changeColor(<span class="number">3000</span>,<span class="string">"green"</span>);</span><br><span class="line">        <span class="keyword">await</span> changeColor(<span class="number">1000</span>, <span class="string">"yellow"</span>);</span><br><span class="line">        <span class="keyword">await</span> changeColor(<span class="number">2000</span>, <span class="string">"red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Q：为什么有的编程规范要求用void 0 代替 undefined?&lt;br&gt;A: undefined 是一个全局变量，可以被修改。为了准备的表达“未定义”，所以使用void 0&lt;/p&gt;
&lt;p&gt;Q：underfined 与 null 的区别？&lt;br&gt;A：underfined 
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
      <category term="面试" scheme="http://blog.zhyat.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析</title>
    <link href="http://blog.zhyat.cn/2019/03/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://blog.zhyat.cn/2019/03/28/复杂度分析/</id>
    <published>2019-03-27T23:51:42.105Z</published>
    <updated>2020-02-12T06:53:02.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;    </span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;      </span><br><span class="line">        sum = sum + i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行代码执行的时间为unit_time<br>第4行第5行分别执行了n遍，所以是 2*n unit_time</p><p>T(n) = O(f(n))<br>T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用f(n)来表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ol><li>只关注执行次数最多的一段代码</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ol><h3 id="最好、最坏时间复杂度"><a href="#最好、最坏时间复杂度" class="headerlink" title="最好、最坏时间复杂度"></a>最好、最坏时间复杂度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>;   </span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; ++i) </span><br><span class="line">    &#123;     </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) </span><br><span class="line">        pos = i;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> pos; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中时间度复杂度会因为x在不在数组中变化，如果x在数组中则O(n)=1,否则O(n)=n。</p><h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><p>要查找的变量x在数组中的位置，有n+1种情况：在数组的0～n-1位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以n+1，就可以得到需要遍历的元素个数的平均值：</p><p>$$<br>\frac{1+2+3+\cdots+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}<br>$$</p><p>考虑到在数组里和不在数组里的概率，以及出现在每个位置的概率，实际上应该是<br>$$<br>\begin{aligned} &amp; 1 \times \frac{1}{2 n}+2 \times \frac{1}{2 n}+3 \times \frac{1}{2 n}+\dots+n \times \frac{1}{2 n}+n \times \frac{1}{2}\ = &amp;\frac{3 n+1}{4} \end{aligned}<br>$$</p><p>用大O表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是O(n)。</p><h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array表示一个长度为n的数组 </span></span><br><span class="line"><span class="comment">// 代码中的array.length就等于n  </span></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];  </span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) </span><br><span class="line">        &#123;           </span><br><span class="line">            sum = sum + <span class="built_in">array</span>[i];        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">array</span>[<span class="number">0</span>] = sum;        </span><br><span class="line">        count = <span class="number">1</span>;     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="built_in">array</span>[count] = val;     </span><br><span class="line">    ++count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$$<br>1 \times \frac{1}{n+1}+1 \times \frac{1}{n+1}+\dots+1 \times \frac{1}{n+1}+n \times \frac{1}{n+1}=O(1)<br>$$</p><p>每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为10的数组array，长度len，下标i。</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= len) <span class="comment">// 数组空间不够了 重新申请一个2倍大小的数组空间</span></span><br><span class="line">    &#123;          </span><br><span class="line">        <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];      </span><br><span class="line">        <span class="comment">// 把原来array数组中的数据依次copy到new_array      </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) </span><br><span class="line">        &#123;        </span><br><span class="line">            new_array[j] = <span class="built_in">array</span>[j];      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">// new_array复制给array，array现在大小就是2倍len了     </span></span><br><span class="line">        <span class="built_in">array</span> = new_array;      </span><br><span class="line">        len = <span class="number">2</span> * len;    </span><br><span class="line">    &#125;    <span class="comment">// 将element放到下标为i的位置，下标i加一   </span></span><br><span class="line">    <span class="built_in">array</span>[i] = element;   </span><br><span class="line">    ++i; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<br>   最好：O(1)<br>   最坏：O(n)<br>   均摊：O(1) 因为前N个操作都是O(1),最后一个均摊到前n个</p><p>空间复杂度：<br>   最好：O(1)<br>   最坏：O(n)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h2&gt;&lt;h3 id=&quot;大O表示法&quot;&gt;&lt;a href=&quot;#大O表示法&quot; class=&quot;headerlink&quot; title=&quot;大O表
      
    
    </summary>
    
      <category term="数据结构与算法｜Algorithm" scheme="http://blog.zhyat.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BD%9CAlgorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript的“面向对象”</title>
    <link href="http://blog.zhyat.cn/2019/02/19/JavaScript%E5%AE%9E%E7%8E%B0%E5%A4%8D%E7%94%A8/"/>
    <id>http://blog.zhyat.cn/2019/02/19/JavaScript实现复用/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2020-02-12T06:52:57.998Z</updated>
    
    <content type="html"><![CDATA[<p>在实现面向对象的编程中，有两种不同的描述对象的方式。一是以Java、C++为代表的基于类的编程语言，二是以JavaScript为代表的基于原型的编程语言。<br>基于“类”关心分类与类，基于“原型”则更关心对象实例。基于“类”的语言总是先有类，然后再去实例化一个对象，类与类之间可以形成继承、组合等关系。但基于”原型“的语言是通过“复制”来创建新的对象。<br>为了使JavaScript更接近基于“类”的实现方式，社区里曾有过不少接近于类Java的风格方言。但在ES6出现后，<code>class</code>已经成为一个关键字，不需要模拟即可实现“类”，但实际上这个“类”还是基于原型对象之上的。</p><p>利用class实现继承<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>可以跑`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>可以四肢腿跑`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>可以两只腿跑`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">'Tom'</span>)</span><br><span class="line"><span class="keyword">let</span> duck = <span class="keyword">new</span> Duck(<span class="string">'Donald'</span>)</span><br><span class="line"></span><br><span class="line">cat.run() <span class="comment">// Tom可以四肢腿跑</span></span><br><span class="line">duck.run()<span class="comment">// Donald可以两只腿跑</span></span><br></pre></td></tr></table></figure></p><p>当然，ES6在操作对象上也提供了几个方法，使得基于原型的思想也同样可以实现继承。提供的方法如下：</p><ul><li><code>Object.create</code></li><li><code>Object.getPrototypeOf</code></li><li><code>Object.sePrototypeOf</code><br>这三个方法具体如何使用请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">MDN</a></li></ul><p>用原型实现的继承<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  run()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我可以跑'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="built_in">Object</span>.create(animal,&#123;</span><br><span class="line">  say()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是cat'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> duck = <span class="built_in">Object</span>.create(animal,&#123;</span><br><span class="line">  say()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我是duck'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someCat = <span class="built_in">Object</span>.create(cat)</span><br><span class="line"><span class="keyword">let</span> someDuck = <span class="built_in">Object</span>.create(duck)</span><br><span class="line"></span><br><span class="line">someCat.say()</span><br><span class="line">someDuck.say()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实现面向对象的编程中，有两种不同的描述对象的方式。一是以Java、C++为代表的基于类的编程语言，二是以JavaScript为代表的基于原型的编程语言。&lt;br&gt;基于“类”关心分类与类，基于“原型”则更关心对象实例。基于“类”的语言总是先有类，然后再去实例化一个对象，类与类
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>js 必须写分号的几种情况</title>
    <link href="http://blog.zhyat.cn/2018/09/07/JS%E5%BF%85%E9%A1%BB%E5%86%99%E5%88%86%E5%8F%B7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/"/>
    <id>http://blog.zhyat.cn/2018/09/07/JS必须写分号的几种情况/</id>
    <published>2018-09-06T16:00:00.000Z</published>
    <updated>2020-02-12T06:52:53.089Z</updated>
    
    <content type="html"><![CDATA[<p>关于 js 写不写分号其实应该算是风格问题，我不写分号的原因觉得 “知道什么时候该加分号比任何时候都加分号要好”，而且我懒。<br><a id="more"></a></p><h3 id="return-语句折行"><a href="#return-语句折行" class="headerlink" title="return 语句折行"></a>return 语句折行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">a:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会在 <code>return</code>后加上分号</p><h3 id="、-、-、"><a href="#、-、-、" class="headerlink" title="[ 、 ( 、 + 、 -"></a>[ 、 ( 、 + 、 -</h3><p>这些情况，在前面加个分号就行。<br>最常见到的就是立即执行函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><p>其次就是forEach了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 js 写不写分号其实应该算是风格问题，我不写分号的原因觉得 “知道什么时候该加分号比任何时候都加分号要好”，而且我懒。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>Typescript 学习笔记—基本语法</title>
    <link href="http://blog.zhyat.cn/2018/09/05/TypeScript%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.zhyat.cn/2018/09/05/TypeScript 入门笔记/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2020-02-12T06:52:49.154Z</updated>
    
    <content type="html"><![CDATA[<p>为什么使用Typescript？类型系统使代码的可读性更高，扩展性好，是JS的超集。</p><a id="more"></a><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="定义变量类型"><a href="#定义变量类型" class="headerlink" title="定义变量类型"></a>定义变量类型</h2><ul><li>如果在定义的时候没有定义类型，TS会自动做类型推论<h3 id="原始数据类型-（Primitive-data-types）"><a href="#原始数据类型-（Primitive-data-types）" class="headerlink" title="原始数据类型 （Primitive data types）"></a>原始数据类型 （Primitive data types）</h3>布尔值、数值、字符串、null、undefined 、Symbol</li></ul><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bur: <span class="built_in">boolean</span> = <span class="literal">false</span> ;</span><br></pre></td></tr></table></figure><p>但需要注意的是用<code>Boolean</code>构造函数创造的不是布尔值而是<code>Boolean</code>对象<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> creatBoolean: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>();</span><br></pre></td></tr></table></figure></p><h4 id="数值（number"><a href="#数值（number" class="headerlink" title="数值（number)"></a>数值（number)</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>;</span><br><span class="line"><span class="comment">// ES6 中的二进制表示法</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;</span><br><span class="line"><span class="comment">// ES6 中的八进制表示法</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;</span><br><span class="line"><span class="keyword">let</span> notANumber: <span class="built_in">number</span> = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> infinityNumber: <span class="built_in">number</span> = <span class="literal">Infinity</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myName: <span class="built_in">string</span> = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="keyword">let</span> myAge: <span class="built_in">number</span> = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;myName&#125;</span>.</span></span><br></pre></td></tr></table></figure><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure><p>可以用来表示没有返回值的函数</p><h3 id="NULL和-Undefined"><a href="#NULL和-Undefined" class="headerlink" title="NULL和 Undefined"></a>NULL和 Undefined</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><code>undefined</code> 类型的变量只能被赋值为 <code>undefined</code>，<code>null</code> 类型的变量只能被赋值为 <code>null</code>。</p><h3 id="对象类型（Object-types）"><a href="#对象类型（Object-types）" class="headerlink" title="对象类型（Object types）"></a>对象类型（Object types）</h3><h3 id="任意值-（Any）"><a href="#任意值-（Any）" class="headerlink" title="任意值 （Any）"></a>任意值 （Any）</h3><p>只有 Any 类型的值允许被赋值成任何类型<br>可以在任意值上访问任意属性和任意方法<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber: <span class="built_in">any</span> = <span class="string">'seven'</span>;</span><br><span class="line">myNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></p><p>** 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 *\*</p><h3 id="未声明类型"><a href="#未声明类型" class="headerlink" title="未声明类型"></a>未声明类型</h3><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型<br>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型</p><h3 id="联合类型-Union-Types）"><a href="#联合类型-Union-Types）" class="headerlink" title="联合类型(Union Types）"></a>联合类型(Union Types）</h3><p>取值可以为多种类型中的一种<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNumber: <span class="built_in">String</span> | <span class="built_in">Number</span>;</span><br><span class="line">myFavoriteNumber  = <span class="string">'seven'</span>;</span><br><span class="line">myFavoriteNumber  = <span class="number">7</span>;</span><br></pre></td></tr></table></figure></p><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么使用Typescript？类型系统使代码的可读性更高，扩展性好，是JS的超集。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://blog.zhyat.cn/categories/JavaScript/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>旋转数组的多种解法</title>
    <link href="http://blog.zhyat.cn/2018/09/05/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%A7%A3%E6%B3%95/"/>
    <id>http://blog.zhyat.cn/2018/09/05/旋转数组的多种解法/</id>
    <published>2018-09-04T16:00:00.000Z</published>
    <updated>2020-02-12T06:52:32.529Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。<br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入: [1,2,3,4,5,6,7] 和 k = 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的原地算法。</li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>执行时间：140 ms 空间复杂度： 时间复杂度：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = nums.splice( nums.length-k, k )</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = temp.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        nums.unshift( temp[i] )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>执行时间</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法｜Algorithm" scheme="http://blog.zhyat.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BD%9CAlgorithm/"/>
    
    
      <category term="LeetCode" scheme="http://blog.zhyat.cn/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>移动端滑动事件</title>
    <link href="http://blog.zhyat.cn/2018/09/04/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.zhyat.cn/2018/09/04/移动端滑动事件/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2020-02-12T06:59:01.752Z</updated>
    
    <content type="html"><![CDATA[<p>在移动端滑动，在一次滑动中可能触发多次事件，通过加锁可以解决</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 左滑</span></span><br><span class="line"><span class="comment">    * @param &#123;object&#125; e 事件对象</span></span><br><span class="line"><span class="comment">    * @returns &#123;boolean&#125; 布尔值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">isLeftSlide</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> startX = gesture.startX;</span><br><span class="line">    <span class="keyword">var</span> startY = gesture.startY;</span><br><span class="line">     <span class="keyword">if</span> (gesture.slideLock) &#123;</span><br><span class="line">       <span class="keyword">var</span> t = e.originalEvent.changedTouches[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> deltaX = t.clientX - startX</span><br><span class="line">       <span class="keyword">var</span> deltaY = t.clientY - startY</span><br><span class="line">       <span class="keyword">if</span> (deltaX &lt; <span class="number">-20</span> &amp;&amp; deltaX &gt; <span class="number">-40</span> &amp;&amp; deltaY &lt; <span class="number">8</span> &amp;&amp; deltaY &gt; <span class="number">-8</span>) &#123;</span><br><span class="line">         gesture.slideLock = <span class="literal">false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 右滑</span></span><br><span class="line"><span class="comment">    * @param &#123;object&#125; e 事件对象</span></span><br><span class="line"><span class="comment">    * @returns &#123;boolean&#125; 布尔值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">isRightSlide</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> startX = gesture.startX;</span><br><span class="line">       <span class="keyword">var</span> startY = gesture.startY;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (gesture.slideLock) &#123;</span><br><span class="line">       <span class="keyword">var</span> t = e.originalEvent.changedTouches[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> deltaX = t.clientX - startX</span><br><span class="line">       <span class="keyword">var</span> deltaY = t.clientY - startY</span><br><span class="line">       <span class="keyword">if</span> (deltaX &gt; <span class="number">20</span> &amp;&amp; deltaX &lt; <span class="number">40</span> &amp;&amp; deltaY &lt; <span class="number">8</span> &amp;&amp; deltaY &gt; <span class="number">-8</span>) &#123;</span><br><span class="line">         gesture.slideLock = <span class="literal">false</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">touchstart</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'e'</span>,e);</span><br><span class="line">       <span class="keyword">var</span> t = e.originalEvent.changedTouches[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">var</span> startX = t.clientX;</span><br><span class="line">       <span class="keyword">var</span> startY = t.clientY;</span><br><span class="line">       gesture.slideLock = <span class="literal">true</span>; <span class="comment">// 滑动事件加锁</span></span><br><span class="line"></span><br><span class="line">       gesture.startX = startX;</span><br><span class="line">       gesture.startY = startY;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">touchmove</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (isLeftSlide(e)) &#123;</span><br><span class="line">         alert(<span class="string">'left'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (isRightSlide(e)) &#123;</span><br><span class="line">        alert(<span class="string">'right'</span>);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   $(<span class="string">'body'</span>).touchstart(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">       touchstart(e);</span><br><span class="line">   &#125;);</span><br><span class="line">   $(<span class="string">'body'</span>).touchmove(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">       touchmove(e);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在移动端滑动，在一次滑动中可能触发多次事件，通过加锁可以解决&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.zhyat.cn/categories/JavaScript/"/>
    
      <category term="JQuery" scheme="http://blog.zhyat.cn/categories/JavaScript/JQuery/"/>
    
    
      <category term="FrontEnd" scheme="http://blog.zhyat.cn/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>使用Jest测试JavaScript</title>
    <link href="http://blog.zhyat.cn/2018/09/04/%E4%BD%BF%E7%94%A8Jest%E6%B5%8B%E8%AF%95JavaScript/"/>
    <id>http://blog.zhyat.cn/2018/09/04/使用Jest测试JavaScript/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2020-02-12T06:26:14.344Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Jest 是 Facebook 的一套开源的 JavaScript 测试框架， 它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架。并且它对同样是 Facebook 的开源前端框架 React 的测试十分友好。</p></blockquote><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>npm init -y</li><li>npm install -D jest babel-jest babel-core babel-preset-env regenerator-runtime</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>在项目根目录添加<code>.babelrc</code>文件</li><li><p>在文件中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打开<code>package.json</code>文件，将<code>script</code>下的<code>test</code>的值修改为<code>jest</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "jest"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="编写测试方法"><a href="#编写测试方法" class="headerlink" title="编写测试方法"></a>编写测试方法</h2><ol><li><p>创建<code>src</code>和<code>test</code>目录及相关文件</p><ul><li>在项目根目录下创建<code>src</code>目录，并在<code>src</code>目录下添加<code>functions.js</code>文件</li><li>在项目根目录下创建<code>test</code>目录，并在<code>test</code>目录下创建<code>functions.test.js</code>文件</li><li>测试文件的文件名 = 被测试模块名 + .test.js，例如被测试模块为<code>functions.js</code>，那么对应的测试文件命名为<code>functions.test.js</code>。</li><li><code>Jest</code> 会自动找到项目中所有使用<code>.spec.js</code>或<code>.test.js</code>文件命名的测试文件并执行</li></ul></li><li><p>在<code>src/functions.js</code>中创建被测试的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  sum(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>test/functions.test.js</code>文件中创建测试用例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functions  <span class="keyword">from</span> <span class="string">'../src/functions'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'sum(2 + 2) 等于 4'</span>, () =&gt; &#123;</span><br><span class="line">  expect(functions.sum(<span class="number">2</span>, <span class="number">2</span>)).toBe(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Jest 是 Facebook 的一套开源的 JavaScript 测试框架， 它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架。并且它对同样是 Facebook 的开源前端框架 React 的测试十分友好。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="测试｜Test" scheme="http://blog.zhyat.cn/categories/%E6%B5%8B%E8%AF%95%EF%BD%9CTest/"/>
    
    
  </entry>
  
  <entry>
    <title>同步微博到推特或脸书</title>
    <link href="http://blog.zhyat.cn/2018/03/09/%E5%90%8C%E6%AD%A5%E5%BE%AE%E5%8D%9A%E5%88%B0%E6%8E%A8%E7%89%B9%E6%88%96%E8%84%B8%E4%B9%A6/"/>
    <id>http://blog.zhyat.cn/2018/03/09/同步微博到推特或脸书/</id>
    <published>2018-03-08T16:00:00.000Z</published>
    <updated>2020-02-12T06:38:08.616Z</updated>
    
    <content type="html"><![CDATA[<p>同步微博到推特或脸书</p><a id="more"></a><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><ol><li>在 <a href="https://ifttt.com/" target="_blank" rel="noopener">IFTTT</a> 注册一个帐号</li><li>在 <a href="https://www.integromat.com/" target="_blank" rel="noopener">integromat</a> 注册一个帐号</li></ol><p><em>这两个网站均可以用 Google 或 FB 帐号登录。</em></p><h4 id="在-IFTTT-上添加-“发送新微博的触发”"><a href="#在-IFTTT-上添加-“发送新微博的触发”" class="headerlink" title="在 IFTTT 上添加 “发送新微博的触发”"></a>在 <a href="https://ifttt.com/" target="_blank" rel="noopener">IFTTT</a> 上添加 “发送新微博的触发”</h4><h5 id="连接-Weibo-、Facebook-、Twitter"><a href="#连接-Weibo-、Facebook-、Twitter" class="headerlink" title="连接 Weibo 、Facebook 、Twitter"></a>连接 Weibo 、Facebook 、Twitter</h5><ol><li>在 IFTTT 的主页面，点击 Search</li><li>分别搜索 Weibo 、Facebook 、Twitter</li><li>以 Weibo 为例，搜索框输入 Weibo 之后，点击 Services 下的图标，在弹出的新页面选择授权</li></ol><h5 id="同步原创纯文本微博"><a href="#同步原创纯文本微博" class="headerlink" title="同步原创纯文本微博"></a>同步原创纯文本微博</h5><h6 id="1-Facebook"><a href="#1-Facebook" class="headerlink" title="1. Facebook"></a>1. Facebook</h6><ul><li>点击在右上角用户名下拉框，选择 New Applet</li><li>点击页面上蓝色字  this</li><li>在 Search services 搜索  webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger</li><li>点击页面上蓝色字 that</li><li>在 Search services 搜索  Facebook，依次点击 Facebook -> Creat a status message，Status message 中填写  ，点击  Create action</li><li>点击 Finish</li></ul><h6 id="2-Twitter"><a href="#2-Twitter" class="headerlink" title="2. Twitter"></a>2. Twitter</h6><ul><li>点击在右上角用户名下拉框，选择 New Applet</li><li>点击页面上蓝色字  this</li><li>在 Search services 搜索  webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger</li><li>点击页面上蓝色字 that</li><li>在 Search services 搜索 Twitter，依次点击 Twitter -> Post a tweet，Tweet text 中填写  ，点击  Create action</li><li>点击 Finish</li></ul><h5 id="同步原创带图片微博"><a href="#同步原创带图片微博" class="headerlink" title="同步原创带图片微博"></a>同步原创带图片微博</h5><h6 id="1-Facebook-1"><a href="#1-Facebook-1" class="headerlink" title="1. Facebook"></a>1. Facebook</h6><ul><li>点击在右上角用户名下拉框，选择 New Applet</li><li>点击页面上蓝色字  this</li><li>在 Search services 搜索  webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 ImageWeibo，点击 Creat trigger</li><li>点击页面上蓝色字 that</li><li>在 Search services 搜索  Facebook，依次点击 Facebook -> Upload a photo from URL，Message 中填写  ，Photo Url 中填写  ，点击  Create action</li><li>点击 Finish</li></ul><h6 id="2-Twitter-1"><a href="#2-Twitter-1" class="headerlink" title="2. Twitter"></a>2. Twitter</h6><ul><li><p>点击在右上角用户名下拉框，选择 New Applet</p></li><li><p>点击页面上蓝色字  this</p></li><li><p>在 Search services 搜索  webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger</p></li><li><p>点击页面上蓝色字 that</p></li><li><p>在 Search services 搜索  Twitter，依次点击 Twitter -> Post a tweet with image</p></li></ul><p>，Tweet text 中填写  ，Image URL 填写  ，点击  Create action</p><ul><li>点击 Finish</li></ul><h5 id="webhook-的触发地址"><a href="#webhook-的触发地址" class="headerlink" title="webhook 的触发地址"></a>webhook 的触发地址</h5><ul><li>点击在右上角用户名下拉框，选择 Services</li><li>搜索 Webhooks</li><li>点击 Documentation</li><li>将 Key 记下来</li></ul><p><em>因为 IFTTT 发送带图片和不带图片是不同的方式，所以必须设置两个 IFTTT 的 APPLET</em></p><h4 id="通过-integromat-将两条规则分发"><a href="#通过-integromat-将两条规则分发" class="headerlink" title="通过 integromat 将两条规则分发"></a>通过 <a href="https://www.integromat.com/" target="_blank" rel="noopener">integromat</a> 将两条规则分发</h4><h5 id="1-设置-webhook"><a href="#1-设置-webhook" class="headerlink" title="1. 设置 webhook"></a>1. 设置 webhook</h5><ul><li>选择 Create a new scenario</li></ul><ul><li>点击？号图标，搜索 webhook</li><li>依次选择 webhooks -> Custom Webhook</li><li>点击 Webhooks 的图标，点击下拉框旁的 Add</li><li>Webhook name 填写 IFTTT weibo webhook</li><li>点击左下角的 Show advanced settings</li><li>Data structure 右侧点击 Add</li><li>Data Structure name 填写 Weibo data structure</li><li>点击 Generator</li><li>Content type 选择 Query String</li><li>Sample data 填写：text=text&amp;image=imageUrl</li><li>点击 Save , 点击 Add data structure 表单的 Save，点击 Add a hook 表单的 Save</li></ul><p><img src="//blog.zhyat.cn/2018/03/09/同步微博到推特或脸书/webhook.gif" alt="webhook"></p><h5 id="2-测试是否正常工作"><a href="#2-测试是否正常工作" class="headerlink" title="2. 测试是否正常工作"></a>2. 测试是否正常工作</h5><ul><li>复制 Webhooks 表单中给出的 URL</li><li>在这个 URL 后面拼接 ?text=text&amp;image=imageUrl</li><li>在浏览器地址栏中粘贴</li><li>若 Webhooks 表单给出 Successfuly determined 表示成功运转</li><li>然后将 Webhooks 表单中给出的 URL 记录下来</li></ul><p><img src="//blog.zhyat.cn/2018/03/09/同步微博到推特或脸书/%E6%B5%8B%E8%AF%95%E8%BF%90%E8%BD%AC.jpg" alt="测试运转"></p><h5 id="3-设置-Router"><a href="#3-设置-Router" class="headerlink" title="3. 设置 Router"></a>3. 设置 Router</h5><ul><li><p>点 webhook 图标右边的半圆，选择 Router</p></li><li><p>设置第一条</p><ul><li>点第一条分支的虚线中间部分，点击 set up a filter</li><li>Lable 填 Image weibo，Condition 输入框选左边的 image，下拉框选择 exists，点击 ok</li><li>点击这条分支的末端图标问号，搜索 HTTP</li><li>点击 HTTP，选择 Make a request</li><li>在 <a href="https://maker.ifttt.com/trigger/imageWeibo/with/key/" target="_blank" rel="noopener">https://maker.ifttt.com/trigger/imageWeibo/with/key/</a> 后加上在 IFTTT 步骤记录下来的 Key</li><li>Method 选择 POST，Body Type 选择 application/x-www-form-urlencode</li><li>点击 Add item，Key 填 value1，点击 value 的输入框，选择 text</li><li>点击 Add item，key 填写 value2，点击 value 的输入框，选择 image</li><li>点击 ok</li></ul></li><li><p>设置第二条</p><ul><li>点第二条分支的虚线中间部分，点击 set up a filter</li><li>Lable 填 Text weibo，Condition 输入框选左边的 image，下拉框选择 Does not exist </li><li>点击右下角 Add and rule，点击输入框，选择 text，下拉框选择 Dose not matches Pattern (case insensitive)，下面的输入框输入 (Repost)|(转发微博）|(\/\/)|( 轉發微博，点击 ok</li><li>点击这条分支的末端图标问号，搜索 HTTP</li><li>点击 HTTP，选择 Make a request</li><li>在 <a href="https://maker.ifttt.com/trigger/imageWeibo/with/key/" target="_blank" rel="noopener">https://maker.ifttt.com/trigger/imageWeibo/with/key/</a> 后加上在 IFTTT 步骤记录下来的 Key</li><li>Method 选择 POST，Body Type 选择 application/x-www-form-urlencode</li><li>点击 Add item，Key 填 value1，点击 value 的输入框，选择 text</li><li>点击 ok</li></ul><p>上述步骤完成后，点击右下角保存，并确定此 scenarios 正在运行</p></li></ul><h4 id="在-IFTTT-中创建触发器"><a href="#在-IFTTT-中创建触发器" class="headerlink" title="在 IFTTT 中创建触发器"></a>在 IFTTT 中创建触发器</h4><ul><li>点击页面上蓝色字  this</li><li>在 Search services 搜索  weibo，选择 New post by you，点击 Creat trigger</li><li>点击页面上蓝色字 that</li><li>在 Search services 搜索 webhook，选择 Make a Web request，在 URL 中填写在 integromat Webhooks 表单中拿到的 URL，点击  Create action</li><li>点击 Finish</li></ul><p>然后就可以同步微博上的原创微博了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同步微博到推特或脸书&lt;/p&gt;
    
    </summary>
    
      <category term="工具｜Tools" scheme="http://blog.zhyat.cn/categories/%E5%B7%A5%E5%85%B7%EF%BD%9CTools/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 科学计算可视化--管线与数据加载</title>
    <link href="http://blog.zhyat.cn/2017/12/19/Tvtk%E7%AE%A1%E7%BA%BF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD/"/>
    <id>http://blog.zhyat.cn/2017/12/19/Tvtk管线与数据加载/</id>
    <published>2017-12-18T16:00:00.000Z</published>
    <updated>2020-02-12T06:28:12.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管线（Pipeline）"><a href="#管线（Pipeline）" class="headerlink" title="管线（Pipeline）"></a>管线（Pipeline）</h2><p><img src="//blog.zhyat.cn/2017/12/19/Tvtk管线与数据加载/可视化.png" alt="可视化"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tvtk.api <span class="keyword">import</span> tvtk</span><br><span class="line"><span class="comment"># 可视化管线</span></span><br><span class="line"><span class="comment"># 创建一个长方体数据源 </span></span><br><span class="line">s = tvtk.CubeSource(x_length=<span class="number">1.0</span>, y_length=<span class="number">2.0</span>, z_length=<span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 将其映射为图形数据 </span></span><br><span class="line">m = tvtk.PolyDataMapper(input_connection=s.output_port)</span><br><span class="line"><span class="comment"># 图形管线</span></span><br><span class="line"><span class="comment"># 创建一个Actor </span></span><br><span class="line">a = tvtk.Actor(mapper=m)</span><br><span class="line"><span class="comment"># 创建一个Rnderer </span></span><br><span class="line">r = tvtk.Renderer(background=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 将Actor添加到Renderer中 </span></span><br><span class="line">r.add_actor(a)</span><br><span class="line"><span class="comment"># 创建一个窗口 </span></span><br><span class="line">w = tvtk.RenderWindow(size=(<span class="number">300</span>, <span class="number">300</span>))</span><br><span class="line"><span class="comment"># 将Renderer添加到窗口中 </span></span><br><span class="line">w.add_renderer(r)</span><br><span class="line"><span class="comment"># 添加交互工具 </span></span><br><span class="line">i = tvtk.RenderWindowInteractor(render_window=w)</span><br><span class="line"><span class="comment"># 开启交互 </span></span><br><span class="line">i.initialize()</span><br><span class="line">i.start()</span><br></pre></td></tr></table></figure><h3 id="可视化管线"><a href="#可视化管线" class="headerlink" title="可视化管线"></a>可视化管线</h3><p>将原始数据加工成图形数据的过程</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>CubeSourece</td><td>通过程序内部计算输出一组描述长方体的数据（PloyData）</td></tr><tr><td>PolyDataMapper</td><td>PolyData通过该映射器将数据映射为图形数据（mapper）</td></tr></tbody></table><h3 id="图形管线"><a href="#图形管线" class="headerlink" title="图形管线"></a>图形管线</h3><p>图形数据加工为我们所看到的图像的过程</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Actor</td><td>场景中的一个实体。它包括一个图形数据（mapper），具有描述该实体的位置，方向，大小的属性。</td></tr><tr><td>Renderer</td><td>渲染的场景。它包括多个需要渲染的Actor</td></tr><tr><td>RenderWindow</td><td>渲染用的图形窗口，它包括一个或者多个Render</td></tr><tr><td>RenderWindowInteractor</td><td>给图形窗口提供一些用户交互功能，例如平移、旋转、放大缩小。这些交互式操作并不改变Actor或者图形数据的属性，只是调整场景中的照相机（Camera）的一些设置。</td></tr></tbody></table><h3 id="观察Tvtk的管线"><a href="#观察Tvtk的管线" class="headerlink" title="观察Tvtk的管线"></a>观察Tvtk的管线</h3><p>使用ivtk显示立方体<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tvtk.api <span class="keyword">import</span> tvtk</span><br><span class="line"><span class="keyword">from</span> tvtk.tools <span class="keyword">import</span> ivtk</span><br><span class="line"><span class="keyword">from</span> pyface.api <span class="keyword">import</span> GUI</span><br><span class="line"></span><br><span class="line">s = tvtk.CubeSource(x_length=<span class="number">1.0</span>, y_length=<span class="number">2.0</span>, z_length=<span class="number">3.0</span>)</span><br><span class="line">m = tvtk.PolyDataMapper(input_connection=s.output_port)</span><br><span class="line">a = tvtk.Actor(mapper=m)</span><br><span class="line"><span class="comment"># 创建一个窗口</span></span><br><span class="line">gui = GUI()</span><br><span class="line">win = ivtk.IVTKWithCrustAndBrowser()</span><br><span class="line">win.open()</span><br><span class="line">win.scene.add_actor(a)</span><br><span class="line"><span class="comment"># 修正窗口显示错误</span></span><br><span class="line">dialog = win.control.centralWidget().widget(<span class="number">0</span>).widget(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">from</span> pyface.qt <span class="keyword">import</span> QtCore</span><br><span class="line">dialog.setWindowFlags(QtCore.Qt.WindowFlags(<span class="number">0x00000000</span>))</span><br><span class="line">dialog.show()</span><br><span class="line"><span class="comment"># 开始界面消息循环</span></span><br><span class="line">gui.start_event_loop()</span><br></pre></td></tr></table></figure></p><p><img src="//blog.zhyat.cn/2017/12/19/Tvtk管线与数据加载/tools.jpg" alt="tools"></p><h3 id="照相机属性"><a href="#照相机属性" class="headerlink" title="照相机属性"></a>照相机属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>clipping_plane</td><td>它有两个元素，分别表示照相机到近、远两个裁剪 平面的距离。在这两个平面范围之外将不会显示</td></tr><tr><td>position</td><td>照相机在三维空间中的坐标</td></tr><tr><td>focal_point</td><td>照相机所聚焦的焦点坐标</td></tr><tr><td>view_up</td><td>照相机的上方向矢量</td></tr></tbody></table><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><ul><li>点（Point）和数据（Data）</li><li>点之间：连接 VS 非连接</li><li>多个相关的点组成单元</li><li>点的连接：显示 VS 隐式</li></ul><h3 id="数据集的类型"><a href="#数据集的类型" class="headerlink" title="数据集的类型"></a>数据集的类型</h3><table><thead><tr><th>数据集</th><th>点的连接</th><th>特点</th></tr></thead><tbody><tr><td>ImageData</td><td>隐式</td><td>二维或三维图像的数据结构</td></tr><tr><td>RectilinearGrid</td><td>隐式</td><td>间距不均匀的网格，所有点都在正交的网格上</td></tr><tr><td>StructuredGild</td><td>隐式</td><td>创建任意形状的网格，需要指定点的坐标</td></tr><tr><td>PolyData</td><td>显式</td><td>由一系列的点、点之间的联系以及由点构成的多边形组成</td></tr></tbody></table><h2 id="Tvtk库的数据加载"><a href="#Tvtk库的数据加载" class="headerlink" title="Tvtk库的数据加载"></a>Tvtk库的数据加载</h2><p>TVTK模型读取<br><code>s = tvtk.STLReader(file_name = &quot;stl文件名&quot;)</code></p><p>TVTK MultiBlock数据读取</p><ul><li>Plot3D</li><li>网格 (XYZ 文件)</li><li>空气动力学结果 (Q 文件)</li><li>通用结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tvtk.api <span class="keyword">import</span> tvtk</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">()</span>:</span><span class="comment"># 读入数据</span></span><br><span class="line">    plot3d = tvtk.MultiBlockPLOT3DReader(</span><br><span class="line">            xyz_file_name=<span class="string">"combxyz.bin"</span>,<span class="comment">#网格文件</span></span><br><span class="line">            q_file_name=<span class="string">"combq.bin"</span>,<span class="comment">#空气动力学结果文件</span></span><br><span class="line">            scalar_function_number=<span class="number">100</span>,<span class="comment">#设置标量数据数量</span></span><br><span class="line">            vector_function_number=<span class="number">200</span><span class="comment">#设置矢量数据数量</span></span><br><span class="line">            )</span><br><span class="line">    plot3d.update()</span><br><span class="line">    <span class="keyword">return</span> plot3d</span><br><span class="line"> </span><br><span class="line">plot3d = read_data()</span><br><span class="line">grid = plot3d.output.get_block(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;管线（Pipeline）&quot;&gt;&lt;a href=&quot;#管线（Pipeline）&quot; class=&quot;headerlink&quot; title=&quot;管线（Pipeline）&quot;&gt;&lt;/a&gt;管线（Pipeline）&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;//blog.zhyat.cn/2017/12/19/Tvtk管线与数据加载/可视化.png&quot; alt=&quot;可视化&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.zhyat.cn/categories/Python/"/>
    
      <category term="Tvtk" scheme="http://blog.zhyat.cn/categories/Python/Tvtk/"/>
    
    
      <category term="三维可视化" scheme="http://blog.zhyat.cn/tags/%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Python 科学计算可视化--三维可视化基础</title>
    <link href="http://blog.zhyat.cn/2017/12/11/Python%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.zhyat.cn/2017/12/11/Python三维可视化基础/</id>
    <published>2017-12-10T16:00:00.000Z</published>
    <updated>2020-02-12T06:31:06.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="科学计算可视化的分类"><a href="#科学计算可视化的分类" class="headerlink" title="科学计算可视化的分类"></a>科学计算可视化的分类</h2><a id="more"></a><h3 id="信息可视化"><a href="#信息可视化" class="headerlink" title="信息可视化"></a>信息可视化</h3><ul><li>信息</li><li>知识</li></ul><h3 id="科学可视化"><a href="#科学可视化" class="headerlink" title="科学可视化"></a>科学可视化</h3><ul><li>空间数据</li></ul><h2 id="科学可视化的可视化方法"><a href="#科学可视化的可视化方法" class="headerlink" title="科学可视化的可视化方法"></a>科学可视化的可视化方法</h2><h3 id="二维标量数据场"><a href="#二维标量数据场" class="headerlink" title="二维标量数据场"></a>二维标量数据场</h3><ul><li>颜色映射法</li><li>等值线方法</li><li>立体图法和层次分割法</li></ul><h3 id="三维标量数据场"><a href="#三维标量数据场" class="headerlink" title="三维标量数据场"></a>三维标量数据场</h3><ul><li>面绘制法</li><li>体绘制法</li></ul><h3 id="矢量数据场"><a href="#矢量数据场" class="headerlink" title="矢量数据场"></a>矢量数据场</h3><ul><li>直接法</li><li>流线法</li></ul><h2 id="TVTK库的安装"><a href="#TVTK库的安装" class="headerlink" title="TVTK库的安装"></a>TVTK库的安装</h2><p>三维可视化工具<br>Windows10 64位 + Python3.6，在库文件所在目录里依次安装：</p><ul><li>VTK-7.1.1-cp36-cp36m-win_amd64.whl</li><li>numpy-1.12.1+mkl-cp36-cp36m-win_amd64.whl</li><li>traits-4.6.0-cp36-cp36m-win_amd64.whl</li><li>mayavi-4.5.0+vtk71-cp36-cp36m-win_amd64.whl</li><li>PyQt4-4.11.4-cp36-cp36m-win_amd64.whl</li></ul><p>在.whl文件目录下用管理员身份运行cmd,在cmd中输入<code>pip install xxx.whl</code></p><h2 id="创建一个TVTK的基本三维对象"><a href="#创建一个TVTK的基本三维对象" class="headerlink" title="创建一个TVTK的基本三维对象"></a>创建一个TVTK的基本三维对象</h2><p><code>s = tvtk.CubeSource(traits)</code></p><h3 id="CubeSoure对象的属性"><a href="#CubeSoure对象的属性" class="headerlink" title="CubeSoure对象的属性"></a>CubeSoure对象的属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>s.x_length</td><td>长方体对象在x轴方向的长度</td></tr><tr><td>s.y_length</td><td>长方体对象在y轴方向的长度</td></tr><tr><td>s.z_length</td><td>长方体对象在z轴方向的长度</td></tr><tr><td>s.center</td><td>长方体对象所在坐标系的原点</td></tr><tr><td>s.output_points_precision</td><td>长方体对象的精度</td></tr></tbody></table><h3 id="CubeSoure对象的常用方法"><a href="#CubeSoure对象的常用方法" class="headerlink" title="CubeSoure对象的常用方法"></a>CubeSoure对象的常用方法</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>set/get_x_length()</td><td>设置/获取长方体对象在x轴方向的长度</td></tr><tr><td>set/get_y_length()</td><td>设置/获取长方体对象在y轴方向的长度</td></tr><tr><td>set/get_z_length()</td><td>设置/获取长方体对象在z轴方向的长度</td></tr><tr><td>set/get_center()</td><td>设置/获取长方体对象所在坐标系的原点</td></tr><tr><td>set/get_bounds()</td><td>设置/获取长方体对象的包围盒</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h3 id="Tvtk库的基本三维对象"><a href="#Tvtk库的基本三维对象" class="headerlink" title="Tvtk库的基本三维对象"></a>Tvtk库的基本三维对象</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>CubeSource</td><td>立方体三维对象数据源</td></tr><tr><td>ConeSource</td><td>圆锥三维对象数据源</td></tr><tr><td>CylinderSource</td><td>圆柱三维对象数据源</td></tr><tr><td>ArcSource</td><td>圆弧三维对象数据源</td></tr><tr><td>ArrowSource</td><td>箭头三维对象数据源</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><p>示例</p><p><code>s = tvtk.ConeSource(height=3.0,radius=1.0,resolution=36)</code></p><h2 id="tvtk库显示一个三维对象"><a href="#tvtk库显示一个三维对象" class="headerlink" title="tvtk库显示一个三维对象"></a>tvtk库显示一个三维对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入tvtk库</span></span><br><span class="line"><span class="keyword">from</span> tvtk.api <span class="keyword">import</span> tvtk</span><br><span class="line"><span class="comment"># 创建一个长方体数据源，并且同时设置其长宽高</span></span><br><span class="line">s = tvtk.CubeSource(x_length = <span class="number">1.0</span>,y_length = <span class="number">2.0</span>,z_length = <span class="number">3.0</span>)</span><br><span class="line"><span class="comment"># 转换为图形数据</span></span><br><span class="line">m = tvtk.PolyDataMapper(input_connection = s.output_port)</span><br><span class="line"><span class="comment"># 创建实体</span></span><br><span class="line">a = tvtk.Actor(mapper = m)</span><br><span class="line"><span class="comment"># 创建渲染器，将Actor添加进去</span></span><br><span class="line">r = tvtk.Renderer(background=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">r.add_actor(a)</span><br><span class="line"><span class="comment"># 创建一个窗口，将渲染器添加进去</span></span><br><span class="line">w = tvtk.RenderWindow(size=(<span class="number">300</span>,<span class="number">300</span>))</span><br><span class="line">w.add_renderer(r)</span><br><span class="line"><span class="comment"># 创建一个窗口的交互工具</span></span><br><span class="line">i = tvtk.RenderWindowInteractor(render_window=w)</span><br><span class="line">i.initialize()</span><br><span class="line">i.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;科学计算可视化的分类&quot;&gt;&lt;a href=&quot;#科学计算可视化的分类&quot; class=&quot;headerlink&quot; title=&quot;科学计算可视化的分类&quot;&gt;&lt;/a&gt;科学计算可视化的分类&lt;/h2&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.zhyat.cn/categories/Python/"/>
    
      <category term="Tvtk" scheme="http://blog.zhyat.cn/categories/Python/Tvtk/"/>
    
    
      <category term="三维可视化" scheme="http://blog.zhyat.cn/tags/%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>FCC 高级算法题之验证美国电话号码（Validate US Telephone Numbers）</title>
    <link href="http://blog.zhyat.cn/2017/11/30/FCC%20%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20-%20%E9%AA%8C%E8%AF%81%E7%BE%8E%E5%9B%BD%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/"/>
    <id>http://blog.zhyat.cn/2017/11/30/FCC 高级算法题 - 验证美国电话号码/</id>
    <published>2017-11-29T16:00:00.000Z</published>
    <updated>2020-02-12T06:52:14.081Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://freecodecamp.cn/challenges/validate-us-telephone-numbers" target="_blank" rel="noopener">题目描述</a></p><p>虽然这个题目是高级算法题，实际上是正则表达式的内容，先把正则表达式写出来。观察例子可以得出几个结论：</p><ul><li>电话号码为十位数字（不包括国家码，连接符）</li><li>国家码可以有也可以没有，有的时候只能为1</li><li>没有国家码时，如果电话号码没有连着写，则以334的形式分隔（如果有国家码，则以1334分组）</li><li>不包括国家码的第一组数字，可以用括号包围。</li><li><p>分隔符为空格或连接符，两者不能接连出现</p><a id="more"></a></li></ul><p>那么来逐一实现</p><p>第一步，实现十位数字连接出现和以334的形式出现</p><p>​    <code>\d{3}\d{3}\d{4}</code></p><p>第二步，实现国家码以1出现和不出现</p><p>​    <code>1?\d{3}\d{3}\d{4}</code></p><p>第三步，实现国家码之后可以有空格也可以无空格</p><p>​    <code>1? ?\d{3}\d{3}\d{4}</code></p><p><em>注意不要用 <code>/s</code>来匹配空格，因为<code>/s</code>匹配的是一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格</em></p><p>第四步，实现电话号码之间可以不分隔也可以用空格或连接符分隔</p><p>​    <code>1? ?\d{3}( |-)?\d{3}( |-)?\d{4}</code></p><p>第五步，实现第一组电话号码可以用括号包围，注意括号需要转义</p><p>​    <code>1? ?(\(\d{3}\)|\d{3})( |-)?\d{3}( |-)?\d{4}</code></p><p>第六步，为了保证匹配的是一串完整的号码，而不是某段数字的中间，匹配匹配输入开始和输入结束</p><p>​    <code>^1? ?(\(\d{3}\)|\d{3})( |-)?\d{3}( |-)?\d{4}$</code></p><p>正则表达式写完了，代码就很简单了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">telephoneCheck</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/^1?\s?(\(\d&#123;3&#125;\)|\d&#123;3&#125;)(\s|-)?\d&#123;3&#125;(\s|-)?\d&#123;4&#125;$/</span>.test(str);</span><br><span class="line">&#125;</span><br><span class="line">telephoneCheck(<span class="string">"555-555-5555"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://freecodecamp.cn/challenges/validate-us-telephone-numbers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目描述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然这个题目是高级算法题，实际上是正则表达式的内容，先把正则表达式写出来。观察例子可以得出几个结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电话号码为十位数字（不包括国家码，连接符）&lt;/li&gt;
&lt;li&gt;国家码可以有也可以没有，有的时候只能为1&lt;/li&gt;
&lt;li&gt;没有国家码时，如果电话号码没有连着写，则以334的形式分隔（如果有国家码，则以1334分组）&lt;/li&gt;
&lt;li&gt;不包括国家码的第一组数字，可以用括号包围。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分隔符为空格或连接符，两者不能接连出现&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构与算法｜Algorithm" scheme="http://blog.zhyat.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BD%9CAlgorithm/"/>
    
    
      <category term="FreeCodeCamp" scheme="http://blog.zhyat.cn/tags/FreeCodeCamp/"/>
    
  </entry>
  
</feed>
