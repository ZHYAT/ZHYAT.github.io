<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2019%2F08%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[基本概念定义：保证一个类仅有一个实例,并提供一个访问它的全局访问点。使用场景：全局缓存、Windows对象、登录浮窗等关键：用一个变量来标志是否已经为某个类创建对象，没有则创建，有则返回这个对象 标准单例模式代码实现：javascript code1234567891011121314151617/** * 标准单例模式 * 缺点是使用者必须知道这是个单例类，本来可以直接new xxx，现在变成了xxx.getInstance */var Singleton = function (name) &#123; this.name = name this.instance = null&#125;;Singleton.prototype.getName = function () &#123; alert(this.name)&#125;Singleton.prototype.getInstance = function (name) &#123; if(this.instance!==null)&#123; this.instance = new Singleton(name) &#125; return this.instance&#125; 透明单例模式javascript code12345678910111213141516171819202122/** * 利用闭包和IIFE实现了透明单例模式 * 但违反了单一职责原则 * 缺点是，当不再需要单例时，需要改写构造函数 */var CreateDiv = (function() &#123; var instance var CreateDiv = function(html) &#123; if (instance) &#123; return instance &#125; this.html = html this.init() // 执行init方法 return (instance = this) // 保证只有一个一个对象 &#125; CreateDiv.prototype.init = function() &#123; var div = document.createElement('div') div.innerHTML = this.html document.body.appendChild(div) &#125; return CreateDiv&#125;)() 用代理实现的单例javascript code123456789101112131415161718192021/** * 代理实现单例 * 将负责管理单例的逻辑移到proxySingletonCreate */var CreateSpan = function(html) &#123; this.html = html this.init()&#125;CreateSpan.prototype.init = function() &#123; var span = document.createElement('span') span.innerHTML = this.html document.body.appendChild(span)&#125;var proxySingletonCreate = (function() &#123; var instance return function(html) &#123; if (!instance) [(instance = new CreateSpan('test'))] return instance &#125;&#125;)() 创建单例的通用方法由上可以看出，创建单例的核心即为使用一个变量表示这个对象是否被创建，即：javascript code1234var instanceif(!instance) &#123; instance = xxx&#125; 具体代码实现即为：javascript code12345678910/** * 创建单例的抽象方法 * @param &#123;function&#125; fn */var getSingle = function(fn) &#123; var result return function() &#123; return result || (result = fn.apply(this, arguments)) &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>设计模式/Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计稿中字体对应的字重]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%AD%97%E4%BD%93%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AD%97%E9%87%8D%2F</url>
    <content type="text"><![CDATA[设计师给的标注文件经常会出现一个情况，字重总是通过直接设置具体的字体来指定字重，实际上在font-family那一行Medium指的是字重。 其对应关系大致符合：100 - Thin200 - Extra Light (Ultra Light)300 - Light400 - Regular (Normal、Book、Roman)500 - Medium600 - Semi Bold (Demi Bold)700 - Bold800 - Extra Bold (Ultra Bold)900 - Black (Heavy)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 之 Symbol]]></title>
    <url>%2F2019%2F06%2F02%2FES6-Symbol%2F</url>
    <content type="text"><![CDATA[基本概念Symbol 的用法其实很简单，就是创建一个独一无二的值。举个例子：1Symbol() == Symbol() // false 需要注意的是，不能使用 new 创建 Symbol ，因为 Symbol 是一个基本类型。 通常在使用 Symbol 的时候，会在其中加入标识符，例如： 1234567Symbol('foo') // Symbol(foo)Symbol('foo') == Symbol('foo') // falseSymbol('foo').toString() // "Symbol(foo)"Symbol('foo').toString() === Symbol('foo').toString() // true Symbol 有 toString() 方法 主要使用场景作为对象的属性名1234let o = &#123;&#125;let mySymbol = Symbol()o[mySymbol] = 'xxx' 需要注意的是，使用 Symbol 作为属性名时，要用 [] 的方式访问，因为点符号后面跟的只能时字符串。 定义常量保证这些常量不相等12345678let log = &#123;&#125;log.levels = &#123; DEBUG: Symbol('debug'), INFO: Symbol('info'), WARN: Symbol('warn')&#125;;console.log(log.levels.DEBUG, 'debug message')console.log(log.levels.INFO, 'info message') 保证 Switch 按照设计使用12345678910111213const COLOR_RED = Symbol();const COLOR_GREEN = Symbol();function getComplement(color) &#123; switch (color) &#123; case COLOR_RED: return COLOR_GREEN; case COLOR_GREEN: return COLOR_RED; default: throw new Error('Undefined color'); &#125;&#125; 其他Symbol 还有一些其他方法，请参阅读MDN Web Docs 不过需要特别注意的是，Symbol 定义的属性名，在使用 for...in 、for...of 等需要有迭代器的方法时不会出现，要获得一个对象所有的Symbol 属性名可以使用 Object.getOwnPropertySymbols() 方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中判断 this 指向的一些方法]]></title>
    <url>%2F2019%2F05%2F27%2FJavaScript%E4%B8%AD%E5%88%A4%E6%96%ADthis%E6%8C%87%E5%90%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaScript 中的 this 可能是 JS 这门语言中最难的一个关键字，想要去理解 this 运作的原理对 JS 需要一定的使用经验。本文并不深究 this 为什么指向某个地方，本文是一篇方法论的文章，只说明怎么样判断 this 的指向。 误区 this 指向自身 ❌ this 指向函数的作用域 ❌ 正确的说法 this 实际上是发生在函数调用时候的绑定，它指向什么完全取决于函数在哪里调用 看得明明白白，好像自己真的懂了是不是？呵呵，不可能的。 绑定的几条规则默认绑定独立函数调用。 12345function f () &#123; console.log( this.a )&#125;var a = 1f() // 1 f()没有加任何的修饰的函数引用，所以此函数不可能使用其他规则，进而 this 此时指向的就是全局对象。不过需要注意的是，在严格模式中，this 是不可以绑定到全局对象上的。 这条规则就是，别的规则都不生效，那就是这条规则。 隐式绑定当调用位置有上下文对象。 123456789function f () &#123; console.log( this.a )&#125;var o = &#123; a:1, foo: foo&#125;o.foo() // 1 但是这条规则有几个需要注意的场景： 123456789function f () &#123; console.log( this.a )&#125;var o = &#123; a:1, foo: foo&#125;var fCopy = o.foo // 别名fCopy() // TypeError: this is undefined 为什么会出现这种情况呢？因为实际上fCopy 是 foo 的引用, 是一个没有修饰符，即没有上下文对象的函数调用。 显示绑定使用 call 和 apply() 方法123456function f () &#123; console.log( this.a )&#125;var o = &#123; a: 1&#125;f.call(o) 这个很明显了，就是手动的明确的，将f的this指向绑定到o上。 new 绑定1234567function F (a) &#123; this.a = a&#125;var f = new F(1)f.a // 1 js 的 new 实际上不是面向对象如java那种创建一个对象的实例，它是基于原型关系的。 先创建了一个对象，然后连接到到原型上。关于这一块，可以参考 JavaScript 实现复用那篇文章。 优先级别new &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 总结]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一道大厂题-HTTPS握手]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E9%81%93%E5%A4%A7%E5%8E%82%E9%A2%98-HTTPS%E6%8F%A1%E6%89%8B%2F</url>
    <content type="text"><![CDATA[来自Daily-Interview-Question Q：介绍 HTTPS 握手过程 Client Hello Server Hello Certificate Server Hello Done Client Key Exchange Change Cipher Spec Finished Change Cipher Spec Finished 步骤一：客户端发送请求（Client Hello）首先，客户端向服务端提供加密信息的通信。 客户端支持的SSL的指定版本 客户端产生的随机数（Client Random, 稍后用于生成”对话密钥” 客户端支持的加密算法 步骤二：服务器回应（Sever Hello）服务端收到请求，向客户端发出回应 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 一个服务器生成的随机数(Server Random)，稍后用于生成”对话密钥”。 确认使用的加密方法，比如RSA公钥加密。 服务器证书 第一次握手结束 步骤三：发送验证消息SSL服务器将数字证书通过Certificate消息发送给SSL客户端，证书里面包含了网站地址，加密公钥，以及证书的颁发机构。 步骤四：服务器回应结束SSL服务器发送Server Hello Done消息，通知SSL客户端版本和加密套件协商结束，开始进行密钥交换。 步骤五：SSL客户端验证SSL服务器的证书合法后，如果不合法浏览器会提示。如果合法的话，利用证书中的公钥，SSL客户端随机生成的premaster secret（后续加密数据所需要的对称密钥），并通过Client Key Exchange消息发送给SSL服务器。 第二次握手结束 步骤六：SSL客户端发送Change Cipher Spec消息，通知SSL服务器后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。 步骤七：SSL客户端计算已交互的握手消息（除Change Cipher Spec消息外所有已交互的消息）的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL服务器。SSL服务器利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。 步骤八：同样地，SSL服务器发送Change Cipher Spec消息，通知SSL客户端后续报文将采用协商好的密钥和加密套件进行加密和MAC计算。 步骤九：SSL服务器计算已交互的握手消息的Hash值，利用协商好的密钥和加密套件处理Hash值（计算并添加MAC值、加密等），并通过Finished消息发送给SSL客户端。SSL客户端利用同样的方法计算已交互的握手消息的Hash值，并与Finished消息的解密结果比较，如果二者相同，且MAC值验证成功，则证明密钥和加密套件协商成功。 第三次握手结束]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript问答]]></title>
    <url>%2F2019%2F03%2F29%2FJavaScript%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[Q：为什么有的编程规范要求用void 0 代替 undefined?A: undefined 是一个全局变量，可以被修改。为了准备的表达“未定义”，所以使用void 0 Q：underfined 与 null 的区别？A：underfined 是Underfined类型的一个值，是一个名为underfined的变量，表达的意思是“从未赋值”“从未定义”，而null是Nulll类型的一个值，是JavaSript语言的关键字，表达的意思是“定义了但是为空” Q：0.1+0.2 不能 = 0.3？怎么比较浮点数？A：Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON，浮点数的特性决定了等式两边相差了微小的值，应该比较等式两边之差是否小于最小精度值 Q：为什么parseInt推荐传入第二个参数？A：在不传入第二个参数的时候，parseInt默认转换0x开头的16进制，还支持0开头的八进制，所以推荐在任何时候都传入第二个参数。parseFloat则直接把字符串作为十进制解析。多数情况下，Number是比parseInt和parseFloat更好的选择。 Q：instanceof、typeof 和 Object.prototype.toString的区别？Q：[‘1’,’2’,’3’].map(parseInt)的结果？ Q: 一个页面如果有一万个Bottom如何绑定事件？A：事件委托，绑定父节点123456789$('.list').on('click', 'li', function(event) &#123; // 绑定事件到父节点 console.log($(event.target).html()); // 注意操作对象是event.target还是this，下面会有详细说明哦&#125;);$('.list').on('click', function(event) &#123; if (event.target.tagName === 'LI') &#123; // 判断标签是不是li，注意tagName属性返回的是大写 console.log($(event.target).html()); &#125;&#125;); Q: 我们现在要实现一个红绿灯，把一个圆形 div 绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色A:123456789101112131415161718function sleep(duration)&#123; return new Promise(function(resolve)&#123; setTimeout(resolve, duration); &#125;)&#125;async function changeColor(duration,color)&#123; document.getElementById("traffic-light").style.background = color; await sleep(duration);&#125;async function main()&#123; while(true)&#123; await changeColor(3000,"green"); await changeColor(1000, "yellow"); await changeColor(2000, "red"); &#125;&#125;main()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂度分析]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[时间复杂度大O表示法123456789int cal(int n) &#123; int sum = 0; int i = 1; for (; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum;&#125; 一行代码执行的时间为unit_time第4行第5行分别执行了n遍，所以是 2*n unit_time T(n) = O(f(n))T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用f(n)来表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。 时间复杂度分析 只关注执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 最好、最坏时间复杂度1234567891011int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123; if (array[i] == x) pos = i; &#125; return pos; &#125; 代码中时间度复杂度会因为x在不在数组中变化，如果x在数组中则O(n)=1,否则O(n)=n。 平均时间复杂度要查找的变量x在数组中的位置，有n+1种情况：在数组的0～n-1位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以n+1，就可以得到需要遍历的元素个数的平均值： $$\frac{1+2+3+\cdots+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}$$ 考虑到在数组里和不在数组里的概率，以及出现在每个位置的概率，实际上应该是$$\begin{aligned} &amp; 1 \times \frac{1}{2 n}+2 \times \frac{1}{2 n}+3 \times \frac{1}{2 n}+\dots+n \times \frac{1}{2 n}+n \times \frac{1}{2}\ = &amp;\frac{3 n+1}{4} \end{aligned}$$ 用大O表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是O(n)。 均摊时间复杂度12345678910111213141516171819// array表示一个长度为n的数组 // 代码中的array.length就等于n int[] array = new int[n]; int count = 0; void insert(int val) &#123; if (count == array.length) &#123; int sum = 0; for (int i = 0; i &lt; array.length; ++i) &#123; sum = sum + array[i]; &#125; array[0] = sum; count = 1; &#125; array[count] = val; ++count; &#125; $$1 \times \frac{1}{n+1}+1 \times \frac{1}{n+1}+\dots+1 \times \frac{1}{n+1}+n \times \frac{1}{n+1}=O(1)$$ 每一次O(n)的插入操作，都会跟着n-1次O(1)的插入操作，所以把耗时多的那次操作均摊到接下来的n-1次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是O(1)。 思考12345678910111213141516171819202122// 全局变量，大小为10的数组array，长度len，下标i。int array[] = new int[10]; int len = 10; int i = 0; // 往数组中添加一个元素void add(int element) &#123; if (i &gt;= len) // 数组空间不够了 重新申请一个2倍大小的数组空间 &#123; int new_array[] = new int[len*2]; // 把原来array数组中的数据依次copy到new_array for (int j = 0; j &lt; len; ++j) &#123; new_array[j] = array[j]; &#125; // new_array复制给array，array现在大小就是2倍len了 array = new_array; len = 2 * len; &#125; // 将element放到下标为i的位置，下标i加一 array[i] = element; ++i; &#125; 时间复杂度： 最好：O(1) 最坏：O(n) 均摊：O(1) 因为前N个操作都是O(1),最后一个均摊到前n个 空间复杂度： 最好：O(1) 最坏：O(n)]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构之美</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的“面向对象”]]></title>
    <url>%2F2019%2F02%2F19%2FJavaScript%E5%AE%9E%E7%8E%B0%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在实现面向对象的编程中，有两种不同的描述对象的方式。一是以Java、C++为代表的基于类的编程语言，二是以JavaScript为代表的基于原型的编程语言。基于“类”关心分类与类，基于“原型”则更关心对象实例。基于“类”的语言总是先有类，然后再去实例化一个对象，类与类之间可以形成继承、组合等关系。但基于”原型“的语言是通过“复制”来创建新的对象。为了使JavaScript更接近基于“类”的实现方式，社区里曾有过不少接近于类Java的风格方言。但在ES6出现后，class已经成为一个关键字，不需要模拟即可实现“类”，但实际上这个“类”还是基于原型对象之上的。 利用class实现继承1234567891011121314151617181920212223242526272829303132333435class Animal&#123; constructor (name) &#123; this.name = name &#125; run() &#123; console.log(`$&#123;this.name&#125;可以跑`) &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name) &#125; run()&#123; console.log(`$&#123;this.name&#125;可以四肢腿跑`) &#125;&#125;class Duck extends Animal &#123; constructor(name) &#123; super(name) &#125; run()&#123; console.log(`$&#123;this.name&#125;可以两只腿跑`) &#125;&#125;let cat = new Cat('Tom')let duck = new Duck('Donald')cat.run() // Tom可以四肢腿跑duck.run()// Donald可以两只腿跑 当然，ES6在操作对象上也提供了几个方法，使得基于原型的思想也同样可以实现继承。提供的方法如下： Object.create Object.getPrototypeOf Object.sePrototypeOf这三个方法具体如何使用请参阅MDN 用原型实现的继承1234567891011121314151617181920212223let animal = &#123; run()&#123; console.log('我可以跑') &#125;&#125;let cat = Object.create(animal,&#123; say()&#123; console.log('我是cat') &#125;&#125;)let duck = Object.create(animal,&#123; say()&#123; console.log('我是duck') &#125;&#125;)let someCat = Object.create(cat)let someDuck = Object.create(duck)someCat.say()someDuck.say()]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回顾2018]]></title>
    <url>%2F2018%2F12%2F09%2F2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一年总是转瞬即逝，大学生涯在这一年悄悄的结束，曾经很难想像的生活就这样猝不及防的到了自己面前，好像什么也没准备好就被推到了生活的前面，成了潮水本身。好像越是长大，对时间的感知越是迟钝。十年之前，一年好像是很久很久才会过完的，而到了如今一年又一年，不过一眨眼的事情。 回顾这一年，经历了很多事情，毕业、工作、独自生活，这些在当时看起来很难的事情，现在却已经无法回顾当时的心情，可能人的确是善于遗忘苦难的。 少年时便离家读书，再加之自己从来也不喜欢热闹，以为自己是惯于自己生活的，可真正独居便还是会常常觉得寂寞。仔细想想，较之从前那十年，现在回到住处可没有舍友可以嬉笑怒骂啊，有时下班得早竟也会觉得无事可做，渐渐地便也不愿早早下班了。有时候深夜醒来，还是恍惚，难道我就这样长大了吗？好像是的，尽管没人教会我，但我好像就这样长大了。 刚毕业时，并没有什么太大的感觉，和舍友道别也不曾觉得感伤，却在时隔半年以后突然感到慌张，“啊？我就这样毕业了吗？”大学四年如今想来甚是浪费，在旁人眼里算是多姿多彩，我却晓得其中是多么的空洞无物，还能想起来大三的时候，自己是多么的为自己的无知感到焦虑，常常在半夜四点醒来，感叹自己这一天又什么都没做成，而如今其实也没有什么改变，却甚是心安理得，到底也是屈从于生活了。 每日干着重复的工作，想去学习却总是给自己找借口说没有时间，甚至于大学时候坚持了许久的跑步也开始落下，这一年是不能让我满意的。找到工作没有费什么劲，只不过是自己也没考虑好自己想要什么，若是新的一年还是如此，便太过于懒散了。 我知道什么时候开始做一件事都不算晚，我也不愿意把什么事情都拖到来年再说，那么至少在年末之前，把《高级程序设计》和《语言精粹》再精读一遍吧。 永远不要停止学习，永远不要忘记自己的无知。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 必须写分号的几种情况]]></title>
    <url>%2F2018%2F09%2F07%2FJS%E5%BF%85%E9%A1%BB%E5%86%99%E5%88%86%E5%8F%B7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[关于 js 写不写分号其实应该算是风格问题，我不写分号的原因觉得 “知道什么时候该加分号比任何时候都加分号要好”，而且我懒。 return 语句折行1234return&#123;a:1&#125; 会在 return后加上分号 [ 、 ( 、 + 、 -这些情况，在前面加个分号就行。最常见到的就是立即执行函数123;(function()&#123;...&#125;)() 其次就是forEach了123;[1,2,3].forEach(function(e)&#123; console.log(e)&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript 学习笔记—基本语法]]></title>
    <url>%2F2018%2F09%2F05%2FTypeScript%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为什么使用Typescript？类型系统使代码的可读性更高，扩展性好，是JS的超集。 基本语法定义变量类型 如果在定义的时候没有定义类型，TS会自动做类型推论原始数据类型 （Primitive data types）布尔值、数值、字符串、null、undefined 、Symbol 布尔值1let bur: boolean = false ; 但需要注意的是用Boolean构造函数创造的不是布尔值而是Boolean对象1let creatBoolean: Boolean = new Boolean(); 数值（number)12345678let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity; 字符串12345let myName: string = 'Tom';let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is $&#123;myName&#125;. 空值1let unusable: void = undefined; 可以用来表示没有返回值的函数 NULL和 Undefined12let u: undefined = undefined;let n: null = null; undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。 对象类型（Object types）任意值 （Any）只有 Any 类型的值允许被赋值成任何类型可以在任意值上访问任意属性和任意方法12let myNumber: any = 'seven';myNumber = 7; ** 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。 *\* 未声明类型变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型 联合类型(Union Types）取值可以为多种类型中的一种123let myNumber: String | Number;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法]]></content>
      <categories>
        <category>前端</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组的多种解法]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 题目描述输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 说明 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 解法解法一执行时间：140 ms 空间复杂度： 时间复杂度：1234567891011/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var rotate = function(nums, k) &#123; let temp = nums.splice( nums.length-k, k ) for( let i = temp.length - 1; i &gt;= 0; i--)&#123; nums.unshift( temp[i] ) &#125;&#125; 解法二执行时间]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jest测试JavaScript]]></title>
    <url>%2F2018%2F09%2F04%2F%E4%BD%BF%E7%94%A8Jest%E6%B5%8B%E8%AF%95JavaScript%2F</url>
    <content type="text"><![CDATA[Jest 是 Facebook 的一套开源的 JavaScript 测试框架， 它自动集成了断言、JSDom、覆盖率报告等开发者所需要的所有测试工具，是一款几乎零配置的测试框架。并且它对同样是 Facebook 的开源前端框架 React 的测试十分友好。 安装 npm init -y npm install -D jest babel-jest babel-core babel-preset-env regenerator-runtime 使用 在项目根目录添加.babelrc文件 在文件中写入 123&#123; &quot;presets&quot;: [&quot;env&quot;]&#125; 打开package.json文件，将script下的test的值修改为jest： 123"scripts": &#123; "test": "jest"&#125; 编写测试方法 创建src和test目录及相关文件 在项目根目录下创建src目录，并在src目录下添加functions.js文件 在项目根目录下创建test目录，并在test目录下创建functions.test.js文件 测试文件的文件名 = 被测试模块名 + .test.js，例如被测试模块为functions.js，那么对应的测试文件命名为functions.test.js。 Jest 会自动找到项目中所有使用.spec.js或.test.js文件命名的测试文件并执行 在src/functions.js中创建被测试的模块 12345export default &#123; sum(a, b) &#123; return a + b; &#125;&#125; 在test/functions.test.js文件中创建测试用例 12345import functions from '../src/functions';test('sum(2 + 2) 等于 4', () =&gt; &#123; expect(functions.sum(2, 2)).toBe(4);&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>使用说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端滑动事件]]></title>
    <url>%2F2018%2F09%2F04%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在移动端滑动，在一次滑动中可能触发多次事件，通过加锁可以解决 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 左滑 * @param &#123;object&#125; e 事件对象 * @returns &#123;boolean&#125; 布尔值 */ function isLeftSlide (e) &#123; var startX = gesture.startX; var startY = gesture.startY; if (gesture.slideLock) &#123; var t = e.originalEvent.changedTouches[0]; var deltaX = t.clientX - startX var deltaY = t.clientY - startY if (deltaX &lt; -20 &amp;&amp; deltaX &gt; -40 &amp;&amp; deltaY &lt; 8 &amp;&amp; deltaY &gt; -8) &#123; gesture.slideLock = false return true &#125; else &#123; return false &#125; &#125; &#125; /** * 右滑 * @param &#123;object&#125; e 事件对象 * @returns &#123;boolean&#125; 布尔值 */ function isRightSlide (e) &#123; var startX = gesture.startX; var startY = gesture.startY; if (gesture.slideLock) &#123; var t = e.originalEvent.changedTouches[0]; var deltaX = t.clientX - startX var deltaY = t.clientY - startY if (deltaX &gt; 20 &amp;&amp; deltaX &lt; 40 &amp;&amp; deltaY &lt; 8 &amp;&amp; deltaY &gt; -8) &#123; gesture.slideLock = false return true &#125; else &#123; return false &#125; &#125; &#125; function touchstart (e) &#123; console.log('e',e); var t = e.originalEvent.changedTouches[0]; var startX = t.clientX; var startY = t.clientY; gesture.slideLock = true; // 滑动事件加锁 gesture.startX = startX; gesture.startY = startY; &#125; function touchmove (e) &#123; if (isLeftSlide(e)) &#123; alert('left'); &#125; if (isRightSlide(e)) &#123; alert('right'); &#125; &#125; $('body').touchstart(function(e)&#123; touchstart(e); &#125;); $('body').touchmove(function(e)&#123; touchmove(e); &#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>JQuery</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步微博到推特或脸书]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%90%8C%E6%AD%A5%E5%BE%AE%E5%8D%9A%E5%88%B0%E6%8E%A8%E7%89%B9%E6%88%96%E8%84%B8%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[同步微博到推特或脸书 前期准备 在 IFTTT 注册一个帐号 在 integromat 注册一个帐号 这两个网站均可以用 Google 或 FB 帐号登录。 在 IFTTT 上添加 “发送新微博的触发”连接 Weibo 、Facebook 、Twitter 在 IFTTT 的主页面，点击 Search 分别搜索 Weibo 、Facebook 、Twitter 以 Weibo 为例，搜索框输入 Weibo 之后，点击 Services 下的图标，在弹出的新页面选择授权 同步原创纯文本微博1. Facebook 点击在右上角用户名下拉框，选择 New Applet 点击页面上蓝色字 this 在 Search services 搜索 webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger 点击页面上蓝色字 that 在 Search services 搜索 Facebook，依次点击 Facebook -> Creat a status message，Status message 中填写 ，点击 Create action 点击 Finish 2. Twitter 点击在右上角用户名下拉框，选择 New Applet 点击页面上蓝色字 this 在 Search services 搜索 webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger 点击页面上蓝色字 that 在 Search services 搜索 Twitter，依次点击 Twitter -> Post a tweet，Tweet text 中填写 ，点击 Create action 点击 Finish 同步原创带图片微博1. Facebook 点击在右上角用户名下拉框，选择 New Applet 点击页面上蓝色字 this 在 Search services 搜索 webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 ImageWeibo，点击 Creat trigger 点击页面上蓝色字 that 在 Search services 搜索 Facebook，依次点击 Facebook -> Upload a photo from URL，Message 中填写 ，Photo Url 中填写 ，点击 Create action 点击 Finish 2. Twitter 点击在右上角用户名下拉框，选择 New Applet 点击页面上蓝色字 this 在 Search services 搜索 webhook，依次点击 webhook -> Connect -> Receive a Web request，在 Event Name 中填写 TextWeibo，点击 Creat trigger 点击页面上蓝色字 that 在 Search services 搜索 Twitter，依次点击 Twitter -> Post a tweet with image ，Tweet text 中填写 ，Image URL 填写 ，点击 Create action 点击 Finish webhook 的触发地址 点击在右上角用户名下拉框，选择 Services 搜索 Webhooks 点击 Documentation 将 Key 记下来 因为 IFTTT 发送带图片和不带图片是不同的方式，所以必须设置两个 IFTTT 的 APPLET 通过 integromat 将两条规则分发1. 设置 webhook 选择 Create a new scenario 点击？号图标，搜索 webhook 依次选择 webhooks -> Custom Webhook 点击 Webhooks 的图标，点击下拉框旁的 Add Webhook name 填写 IFTTT weibo webhook 点击左下角的 Show advanced settings Data structure 右侧点击 Add Data Structure name 填写 Weibo data structure 点击 Generator Content type 选择 Query String Sample data 填写：text=text&amp;image=imageUrl 点击 Save , 点击 Add data structure 表单的 Save，点击 Add a hook 表单的 Save 2. 测试是否正常工作 复制 Webhooks 表单中给出的 URL 在这个 URL 后面拼接 ?text=text&amp;image=imageUrl 在浏览器地址栏中粘贴 若 Webhooks 表单给出 Successfuly determined 表示成功运转 然后将 Webhooks 表单中给出的 URL 记录下来 3. 设置 Router 点 webhook 图标右边的半圆，选择 Router 设置第一条 点第一条分支的虚线中间部分，点击 set up a filter Lable 填 Image weibo，Condition 输入框选左边的 image，下拉框选择 exists，点击 ok 点击这条分支的末端图标问号，搜索 HTTP 点击 HTTP，选择 Make a request 在 https://maker.ifttt.com/trigger/imageWeibo/with/key/ 后加上在 IFTTT 步骤记录下来的 Key Method 选择 POST，Body Type 选择 application/x-www-form-urlencode 点击 Add item，Key 填 value1，点击 value 的输入框，选择 text 点击 Add item，key 填写 value2，点击 value 的输入框，选择 image 点击 ok 设置第二条 点第二条分支的虚线中间部分，点击 set up a filter Lable 填 Text weibo，Condition 输入框选左边的 image，下拉框选择 Does not exist 点击右下角 Add and rule，点击输入框，选择 text，下拉框选择 Dose not matches Pattern (case insensitive)，下面的输入框输入 (Repost)|(转发微博）|(\/\/)|( 轉發微博，点击 ok 点击这条分支的末端图标问号，搜索 HTTP 点击 HTTP，选择 Make a request 在 https://maker.ifttt.com/trigger/imageWeibo/with/key/ 后加上在 IFTTT 步骤记录下来的 Key Method 选择 POST，Body Type 选择 application/x-www-form-urlencode 点击 Add item，Key 填 value1，点击 value 的输入框，选择 text 点击 ok 上述步骤完成后，点击右下角保存，并确定此 scenarios 正在运行 在 IFTTT 中创建触发器 点击页面上蓝色字 this 在 Search services 搜索 weibo，选择 New post by you，点击 Creat trigger 点击页面上蓝色字 that 在 Search services 搜索 webhook，选择 Make a Web request，在 URL 中填写在 integromat Webhooks 表单中拿到的 URL，点击 Create action 点击 Finish 然后就可以同步微博上的原创微博了]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>使用说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 科学计算可视化--管线与数据加载]]></title>
    <url>%2F2017%2F12%2F19%2FTvtk%E7%AE%A1%E7%BA%BF%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[管线（Pipeline） 12345678910111213141516171819202122from tvtk.api import tvtk# 可视化管线# 创建一个长方体数据源 s = tvtk.CubeSource(x_length=1.0, y_length=2.0, z_length=3.0)# 将其映射为图形数据 m = tvtk.PolyDataMapper(input_connection=s.output_port)# 图形管线# 创建一个Actor a = tvtk.Actor(mapper=m)# 创建一个Rnderer r = tvtk.Renderer(background=(0, 0, 0))# 将Actor添加到Renderer中 r.add_actor(a)# 创建一个窗口 w = tvtk.RenderWindow(size=(300, 300))# 将Renderer添加到窗口中 w.add_renderer(r)# 添加交互工具 i = tvtk.RenderWindowInteractor(render_window=w)# 开启交互 i.initialize()i.start() 可视化管线将原始数据加工成图形数据的过程 属性 说明 CubeSourece 通过程序内部计算输出一组描述长方体的数据（PloyData） PolyDataMapper PolyData通过该映射器将数据映射为图形数据（mapper） 图形管线图形数据加工为我们所看到的图像的过程 属性 说明 Actor 场景中的一个实体。它包括一个图形数据（mapper），具有描述该实体的位置，方向，大小的属性。 Renderer 渲染的场景。它包括多个需要渲染的Actor RenderWindow 渲染用的图形窗口，它包括一个或者多个Render RenderWindowInteractor 给图形窗口提供一些用户交互功能，例如平移、旋转、放大缩小。这些交互式操作并不改变Actor或者图形数据的属性，只是调整场景中的照相机（Camera）的一些设置。 观察Tvtk的管线使用ivtk显示立方体12345678910111213141516171819from tvtk.api import tvtkfrom tvtk.tools import ivtkfrom pyface.api import GUIs = tvtk.CubeSource(x_length=1.0, y_length=2.0, z_length=3.0)m = tvtk.PolyDataMapper(input_connection=s.output_port)a = tvtk.Actor(mapper=m)# 创建一个窗口gui = GUI()win = ivtk.IVTKWithCrustAndBrowser()win.open()win.scene.add_actor(a)# 修正窗口显示错误dialog = win.control.centralWidget().widget(0).widget(0)from pyface.qt import QtCoredialog.setWindowFlags(QtCore.Qt.WindowFlags(0x00000000))dialog.show()# 开始界面消息循环gui.start_event_loop() 照相机属性 属性 说明 clipping_plane 它有两个元素，分别表示照相机到近、远两个裁剪 平面的距离。在这两个平面范围之外将不会显示 position 照相机在三维空间中的坐标 focal_point 照相机所聚焦的焦点坐标 view_up 照相机的上方向矢量 数据集 点（Point）和数据（Data） 点之间：连接 VS 非连接 多个相关的点组成单元 点的连接：显示 VS 隐式 数据集的类型 数据集 点的连接 特点 ImageData 隐式 二维或三维图像的数据结构 RectilinearGrid 隐式 间距不均匀的网格，所有点都在正交的网格上 StructuredGild 隐式 创建任意形状的网格，需要指定点的坐标 PolyData 显式 由一系列的点、点之间的联系以及由点构成的多边形组成 Tvtk库的数据加载TVTK模型读取s = tvtk.STLReader(file_name = &quot;stl文件名&quot;) TVTK MultiBlock数据读取 Plot3D 网格 (XYZ 文件) 空气动力学结果 (Q 文件) 通用结果 1234567891011121314from tvtk.api import tvtk def read_data():# 读入数据 plot3d = tvtk.MultiBlockPLOT3DReader( xyz_file_name="combxyz.bin",#网格文件 q_file_name="combq.bin",#空气动力学结果文件 scalar_function_number=100,#设置标量数据数量 vector_function_number=200#设置矢量数据数量 ) plot3d.update() return plot3d plot3d = read_data()grid = plot3d.output.get_block(0)]]></content>
      <categories>
        <category>Python</category>
        <category>Tvtk</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>三维可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 科学计算可视化--三维可视化基础]]></title>
    <url>%2F2017%2F12%2F11%2FPython%E4%B8%89%E7%BB%B4%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[科学计算可视化的分类 信息可视化 信息 知识 科学可视化 空间数据 科学可视化的可视化方法二维标量数据场 颜色映射法 等值线方法 立体图法和层次分割法 三维标量数据场 面绘制法 体绘制法 矢量数据场 直接法 流线法 TVTK库的安装三维可视化工具Windows10 64位 + Python3.6，在库文件所在目录里依次安装： VTK-7.1.1-cp36-cp36m-win_amd64.whl numpy-1.12.1+mkl-cp36-cp36m-win_amd64.whl traits-4.6.0-cp36-cp36m-win_amd64.whl mayavi-4.5.0+vtk71-cp36-cp36m-win_amd64.whl PyQt4-4.11.4-cp36-cp36m-win_amd64.whl 在.whl文件目录下用管理员身份运行cmd,在cmd中输入pip install xxx.whl 创建一个TVTK的基本三维对象s = tvtk.CubeSource(traits) CubeSoure对象的属性 属性 说明 s.x_length 长方体对象在x轴方向的长度 s.y_length 长方体对象在y轴方向的长度 s.z_length 长方体对象在z轴方向的长度 s.center 长方体对象所在坐标系的原点 s.output_points_precision 长方体对象的精度 CubeSoure对象的常用方法 属性 说明 set/get_x_length() 设置/获取长方体对象在x轴方向的长度 set/get_y_length() 设置/获取长方体对象在y轴方向的长度 set/get_z_length() 设置/获取长方体对象在z轴方向的长度 set/get_center() 设置/获取长方体对象所在坐标系的原点 set/get_bounds() 设置/获取长方体对象的包围盒 … … Tvtk库的基本三维对象 属性 说明 CubeSource 立方体三维对象数据源 ConeSource 圆锥三维对象数据源 CylinderSource 圆柱三维对象数据源 ArcSource 圆弧三维对象数据源 ArrowSource 箭头三维对象数据源 … … 示例 s = tvtk.ConeSource(height=3.0,radius=1.0,resolution=36) tvtk库显示一个三维对象123456789101112131415161718# 导入tvtk库from tvtk.api import tvtk# 创建一个长方体数据源，并且同时设置其长宽高s = tvtk.CubeSource(x_length = 1.0,y_length = 2.0,z_length = 3.0)# 转换为图形数据m = tvtk.PolyDataMapper(input_connection = s.output_port)# 创建实体a = tvtk.Actor(mapper = m)# 创建渲染器，将Actor添加进去r = tvtk.Renderer(background=(0,0,0))r.add_actor(a)# 创建一个窗口，将渲染器添加进去w = tvtk.RenderWindow(size=(300,300))w.add_renderer(r)# 创建一个窗口的交互工具i = tvtk.RenderWindowInteractor(render_window=w)i.initialize()i.start()]]></content>
      <categories>
        <category>Python</category>
        <category>Tvtk</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>三维可视化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FCC 高级算法题之验证美国电话号码（Validate US Telephone Numbers）]]></title>
    <url>%2F2017%2F11%2F30%2FFCC%20%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%20-%20%E9%AA%8C%E8%AF%81%E7%BE%8E%E5%9B%BD%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目描述 虽然这个题目是高级算法题，实际上是正则表达式的内容，先把正则表达式写出来。观察例子可以得出几个结论： 电话号码为十位数字（不包括国家码，连接符） 国家码可以有也可以没有，有的时候只能为1 没有国家码时，如果电话号码没有连着写，则以334的形式分隔（如果有国家码，则以1334分组） 不包括国家码的第一组数字，可以用括号包围。 分隔符为空格或连接符，两者不能接连出现 那么来逐一实现 第一步，实现十位数字连接出现和以334的形式出现 ​ \d{3}\d{3}\d{4} 第二步，实现国家码以1出现和不出现 ​ 1?\d{3}\d{3}\d{4} 第三步，实现国家码之后可以有空格也可以无空格 ​ 1? ?\d{3}\d{3}\d{4} 注意不要用 /s来匹配空格，因为/s匹配的是一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格 第四步，实现电话号码之间可以不分隔也可以用空格或连接符分隔 ​ 1? ?\d{3}( |-)?\d{3}( |-)?\d{4} 第五步，实现第一组电话号码可以用括号包围，注意括号需要转义 ​ 1? ?(\(\d{3}\)|\d{3})( |-)?\d{3}( |-)?\d{4} 第六步，为了保证匹配的是一串完整的号码，而不是某段数字的中间，匹配匹配输入开始和输入结束 ​ ^1? ?(\(\d{3}\)|\d{3})( |-)?\d{3}( |-)?\d{4}$ 正则表达式写完了，代码就很简单了 1234function telephoneCheck(str) &#123; return /^1?\s?(\(\d&#123;3&#125;\)|\d&#123;3&#125;)(\s|-)?\d&#123;3&#125;(\s|-)?\d&#123;4&#125;$/.test(str);&#125;telephoneCheck("555-555-5555");]]></content>
      <categories>
        <category>Regexp</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>FreeCodeCamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMScript 6 箭头函数]]></title>
    <url>%2F2017%2F11%2F28%2FECMAScript%206%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[JavaScript 箭头函数是 ECMAScript 6 中引入的编写函数表达式的一种简便方法。 在 JavaScript 中创建一个函数通常有两种方式： 函数语句 函数表达式 但现在还可以使用箭头函数 用函数语句创建一个函数如下： 1234function add(num1,mum2)&#123; var res = num1 + num2; return res;&#125; 但现在用函数表达式只需要一行： 1var add = (num1,num2) =&gt; &#123;return num1 + num2;&#125;; 基本语法规则多参数传递多个参数应该在小括号中传递，如下所示： 1var add = (num1,num2,num3) =&gt; &#123;return num1 + num2 + num3;&#125;; 只传递一个函数的时候，小括号可以省略，如下所示： 1var mul = num =&gt; &#123;return num * 666;&#125;; 不传递参数的时候，小括号不可以省略，如下所示： 1var text = () =&gt; &#123;console.log("hello word")&#125;; 函数主体括号可选 return 语句可选 默认参数箭头函数支持 ES6 的默认参数功能，如下： 1var add = (num1=1,num2=2) =&gt; num1 + num2; 返回对象字面量如果要使用箭头函数返回对象字面量，需要把返回对象装入小括号中，如下： 1234var student = (name,age) =&gt;(&#123; name:name, age:age&#125;); this值箭头函数不会创建自己的this,它使用封闭上下文的this值。 123456789function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| properly refers to the person object &#125;, 1000);&#125;var p = new Person(); 所以在这段代码中，传递给setInterval的函数内的this与封闭函数中的this值相同 使用箭头函数的注意事项不能使用箭头函数作为构造函数，如下；12var Student = (name, age) =&gt; &#123; name = name, age = age &#125;;var jack = new Student("Jack", 6); 箭头函数没有原型12var Student = (name, age) =&gt; &#123; name = name, age = age &#125;;console.log(Student.prototype)]]></content>
      <categories>
        <category>前端</category>
        <category>ECMScript 6</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何看懂铁路图（语法图）]]></title>
    <url>%2F2017%2F10%2F28%2F%E7%9C%8B%E6%87%82%E9%93%81%E8%B7%AF%E5%9B%BE(%E8%AF%AD%E6%B3%95%E5%9B%BE)%2F</url>
    <content type="text"><![CDATA[语法图（Syntax diagrams ）又叫铁路图（railroad diagrams）是描述形式文法的一种方式。它是巴科斯范式或扩展巴科斯范式的图形化表示。最早使用语法图的书包括Niklaus Wirth写的“Pascal User Manual”（语法图开始于47页）和the Burroughs CANDE manual。在编译领域，像BNF和它的变体这样的文字式表示法都是首选的。BNF能很好的被编译器作者和编译器理解，但是不能很好的被这些语言的大部分用户理解。铁路图能更容易被大多数人理解。数据交换格式JSON之所以流行的部分原因就是它用铁路图来表示。 –《维基百科》 准则 从左边界开始沿着轨道去到右边界。 沿途，你将在圆框中遇到的是字面量，在方块中遇到的是规则或者描述。 任何沿着轨道能走通的序列都是合法的。 任何不能沿着轨道走通的序列都是非法的。 每个末端只有一个竖条的铁路图允许在任何一对标记中间插入空白。而在末端有两个竖条的铁路图是不允许的。 示例以《JavaScript语言精粹》第10页的铁路图为例： 一条JavaScript语句可以是： var name = expression; var name1,name2,name3...,name; var name 1,name2,...name3=expression3,...,name=expression; var name 1,name2,...name3=expression3,...,name; var name1=expression1,name2=expression2,name3=expression3...,name=expression; 参考资料 wikipedia Syntax diagram]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加RSS]]></title>
    <url>%2F2017%2F10%2F23%2FHexo%E8%AE%BE%E7%BD%AERSS%2F</url>
    <content type="text"><![CDATA[为Hexo添加RSS订阅模块 安装RSS插件在根目录执行命令 npm install hexo-generator-feed --save 在Hexo中开启RSS支持在网站根目录下的站点配置文件_config.yml Extensions部分中添加 12345678plugin: - hexo-generator-feed # Feed Atomfeed:type: atompath: atom.xmllimit: 20 在主题中开启我使用的是nexT主题，默认开启，不同主题方式不一样，查阅文档即可。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>使用说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows软件推荐清单]]></title>
    <url>%2F2017%2F10%2F22%2F%E8%87%AA%E7%94%A8%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[本文列举了本人常用的软件以及其下载链接，对软件本身也做了简单介绍。好用的软件可能千千万，只是列举了我在同类软件中使用过并且觉得相对来说最好的。 效率屏蔽网站Cold Turkey ：在指定时间屏蔽指定网站，收费版还可以屏蔽软件。 番茄工作法 番茄盒子 ：基于番茄工作法的自我管理软件，功能多而全，包括：目标管理、番茄工作、上网控制、时间记录、总结反思等。 番茄土豆 ：番茄工作法 + to-do list，简单高效，支持iOS、Android、OS、Windows、Chrome拓展。 时间统计工具RescueTime ：自动记录你在电脑或者手机上的时间花费，自动生成数据表格，各个系统都有，也支持Firefox和Chrome。 剪贴板增强工具 Ditto ：开源、免费的剪贴板增强工具，可以把复制过的所有内容保留起来。支持合并粘贴，纯文本粘贴，支持分组、置顶、快速搜索、热键粘贴等功能。 快贴 ：云剪贴板，主要用于多台设备同步。 快速启动工具 wox ：Windows 上的 Alfred，效率神器。快速启动软件，有许多插件可以安装，查看天气，搜索，搜索本地文件等等。 Rolan ：轻量级启动器。 “你可以通过将文件拖到软件窗口中，然后通过像 QQ 一样的吸附或者键盘热键随时呼出，点击图标即可启动，使用起来非常方便快捷！”。@Appinn 快速浏览文件信息QuickLook ：快速预览文件而无需打开其相关的应用程序。 资源管理器增强工具QTTabBar ：不止于给资源文件管理器添加标签页，功能十分强大，不过很久没有更新了。 手势工具WGestures：一个更简单、更现代的鼠标手势。免费 &amp; 开源。 搜索工具everything ：速度最快的文件名搜索工具，甚至支持正则表达式。 工具Markdown编辑器Typora ：极致简洁的颜值非常高的Markdown编辑器，支持实时预览，所见即所得。关键是还免费！ 思维导图XMind ：美观强大，有免费版和收费版。 百度脑图 ：联网就能用，只有web版的，文件可以保存在云端。 知识管理工具幕布 : 记录+整理，支持生成思维导图 笔记 有道云笔记 ：主流平台都支持，而且很多方法扩容。 OneNote ：微软出的，对比市面上的笔记应用手写做得很好。 网盘 OneDrive ：微软家的，普通用户容量5G，office365用户就有1T了。 百度云网盘 ：国内网盘应该只剩这个了，不是会员的话上传下载限速，还可能莫名奇妙丢东西，不过胜在容量大，资源多了。 Dropbox ；在国内可能使用不了。 Google Drive ：15GB容量，可惜在国内使用也不太方便。 解压BandZip ：绝对不仅仅是因为界面相对于老牌的WinRAR和7-zip好看，最重要的是它解决了文件名乱码问题，在解压缩的时候可以选择编码，压缩率也很高。 下载 迅雷极速版 ：简洁干净，无广告，迅雷的良心产品吧，不过现在似乎已经被迅雷下架了。 FreeDownloadManager ：IDM收费，FDM基本上可以作为其替代产品，而且界面真的是比IDM好看很多。 EagleGet ：视频嗅探做得相当好了。 截图录屏 FSCapture ：长期使用，小巧干净，运行内存不到1M。 PicPick ：相对FSCapture好看一些，但功能上个人是觉得不如FSCapture的。 制作Gif图片ScreenToGif ：软件体积非常小，免费、开源，使用起来非常方便。 视频播放器Potplayer ：内置解码器非常强大，几乎可以播放市面上流行的绝大多数视频音频格式并且支持Dxva，定制程度也非常高。 音乐播放器 网易云音乐 ：非常好用，但现在很多歌曲因为版权问题都下架了。 Listen1 ：可以搜索和播放来自网易云音乐，虾米，QQ音乐三个主流音乐网站的歌曲，一个顶三个。 系统清理CCleanner ：小巧快捷干净 开发文本编辑器 Sublime Text 3 Package Control A File Icon AdvancedNewFile Alignment AutoFileName Browser Refresh Color Highlihhter DocBlockr Emmet HTMLBeautify JsFormat Material Theme Side Bar SublimeGit Autoprefixer ConvertToUTF8 CSScomb HTML/CSS/JS Prettify SublimeCodeInter SublimeLinter Terminal ColorPicker OmniMarkupPreviewer Visual Studio Code Auto Rename Tag Beautify change-case Class autocomplete for HTML Codelf colorize CSS Peek Debugger for Chrome Enki Theme ESLint HTML CSS Support HTML Snippets JavaScript Snippet Pack jQuery Code Snippets Material Icon Theme npm open-in-browser Path Autocomplete Quolla.js RegExp Preivew and Editor stylelint SVG VIewer Typlings auto installer Image preview settings Sync 我是从sublime逐渐转到了VSCode，主要用这两个来做前端开发，插件也大多与前端有关 IDE JetBrains系列 ：如果是学生，可以申请免费的注册码。整个系列都非常好用,涵盖了javascript、.net、java、C++、PHP、Ruby&amp;Ralis、Android、macOS&amp;iOS、Python&amp;Django等类型的各种IDE。 Visual Studio ：神器，无需多说 HBuilder ：国产的HTML5 IDE，也相当好用了。 工具 postman ：HTTP请求模拟工具 powershell ：命令行工具 koala ：前端预处理器语言图形编译工具 Git ：分布式版本控制软件 VMware Workstation ：虚拟机 Xshell ：安全终端模拟软件 PxCook : 标注工具 浏览器主要列一下插件 Chrome LastPass ：密码管理 OneTab ：将标签页保存在后台 Adblock PLus ：屏蔽广告 Infinity ：好看的起始页 Pocket ：稍后读 Cato ：chrome的Alfred TamperMoney ：脚本扩展 Aerys ：窗口标签管理器 Insight.io : Github代码浏览插件 Extension Manager ：扩展管理器 BaidudlFirefox Adblock Plus ：屏蔽广告 Insight.io ：Github代码浏览插件 LastPass ：密码管理 Pocket ：稍后读 NerVideoHuter ：流媒体捕获 stylish ：网站样式定制 Super Start ：起始页 Tab Min Plus ：标签页增强 Firefox Developer Edition Laboratory Media Panel React Developer Tools Redux DevTools Spector.js Vue.js devtools Firefox和Firefiox Developer Edition可能会使用同一套用户配置而导致无法同时启动等问题，可以参考设置配置文件解决]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX简述]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%85%B3%E4%BA%8EAjax%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[AJAX全称是”Asynchronous Javascript And XML”，即“异步JavaScript和XML”。 AJAX不是一种新的编程语言，而是一种使用现有标准的新方法。 概述通过XMLHttpRequest，与后台交互数据，实现局部刷新。 同步提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事 异步请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕 概念AJAX应用 使用HTML和CSS完成页面 通过XMLHttpRequest和web服务器进行数据交换 JavaScript DOM操作，完成动态局部刷新 创建XMLHttpRequest对象要使用Ajax，第一步就是实例化XMLHttpRequest对象。 1var request = new XMLHttpReques(); 现代浏览器基本上都支持XMLHttpReques对象，但如果要兼容IE6、IE5的上古浏览器可以这样写： 123456var request;if(windows.XMLHttpReques)&#123; request = new XMLHttpReques();&#125; else &#123; request = new ActiveXObject("Microsoft.XMLHTTP");&#125; HTTPHTTP是一种计算机与计算机网络通信的规则，是无状态的协议，它既不建立持续的连接，也不保留“记忆”。 HTTP请求的过程： 建立TCP连接 浏览器发送请求命令 浏览器发送请求头信息 web服务器应答 web服务器发送应答头信息 web服务器发送应答数据主体 关闭TCP连接 请求组成请求由方法（动作）、URL、请求头、请求体组成。请求头和请求体以空行分隔。 GET和POSTGET：多用于信息获取，用URL传递参数，在发送信息的时候字符有限制，一般在2000个字符左右。也很很多人说GET是幂等的，幂等其实就是执行多次与执行一次并无差别 POST：一般用于修改服务器上的资源。对信息的数量无限制，较之GET更安全。 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求：无法使用缓存文件（更新服务器上的文件或数据库）向服务器发送大量数据（POST 没有数据量限制）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 响应组成 数字和文字组成的状态码 响应头 响应体 状态码通常状态码的首位数字，表示状态码的类型。1 信息，服务器收到请求，需要请求者继续执行操作2 成功，操作被成功接收并处理3 重定向，需要进一步的操作以完成请求4 客户端错误，请求包含语法错误或无法完成请求5** 服务器错误，服务器在处理请求的过程中发生了错误 XMLHttpRequest发送请求方法和属性 规定请求的类型、URL 以及是否异步处理请求。 1open(method,url,async) method: 请求的类型，GET或POST URL：请求的地址 async: true为异步，false为同步，默认为true，可省略 将请求发送到服务器。 1send(string) 仅用于POST 向请求添加HTTP头。 1setRequestHeader(header,value) header: 规定头的名称 value: 规定头的值 5.XMLHttpRequest取得响应5.1 方法和属性 XMLRequest对象的两个属性 获得字符串形式的响应数据 1responseText 获得XML形式的响应数据 1responseXML 以数字或文本返回HTTP状态码 1status,statusText 获取所有响应报头 1getAllResponseHeader() 查询响应中的某个字段的值 1getResponseHeader() 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数 1onreadystatechange readyState属性 readyState属性代表了服务器的变化。 0：请求未初始化，open未调用 1：服务器连接已建立，open已经调用 2：请求已接受，即已接收头信息 3：请求处理中，即已收到响应主体 4：请求已完成，且响应就绪，即响应完成]]></content>
      <categories>
        <category>前端</category>
        <category>AJAX</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery DOM操作]]></title>
    <url>%2F2017%2F09%2F25%2FjQuery%E7%B3%BB%E5%88%97DOM%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Write Less，Do More 从最基本DOM操作开始。 概述jQuery语句组成jQuery的命令都由四个部分组成：\$,selector，action，parmaeters组成，如:$(&#39;P&#39;).css(&#39;color&#39;,&#39;red&#39;); 通常一个命令中包含几件事： 使用选择器选择页面上的一个或多个元素 选择一个操作应用于选择的元素 传入参数 那么，上面那条命令实际上就是： 使用选择器选择了页面上的所有段落元素 操作这个元素的CSS 传入参数，表明是将CSS的color属性设置为红色 当然一提到选择器，就必须提到DOM树。 DOMDOM意为文档对象模型，是HTML表示对象的一种标准方式，是HTML标签的层级化表示。 简单来说，在这个层次中，每个元素都有一个父元素，也可以有一个或多个子元素。每个元素都可以有一个id和一个或多个class。 在这里只是简单提到DOM，需要深入了解的话，可以去看《JavaScript DOM 编程艺术》。 选择选择器基本选择器 选取所有的css标签：$(&quot;*&quot;) 选取所有的id名为id1的标签：$(&quot;#id1&quot;) 选取所有的class名为class_name的标签：$(&quot;.class_name&quot;) 选取所有的标签名为element1的标签：$(&quot;element1&quot;) 选取符合这三个条件中任何一个条件的标签：$(&quot;.class,p,div&quot;) 层级选择器 后代选择器：$(&quot;.father_div div&quot;) 子代选择器：$(&quot;.father_div&gt;div&quot;) 毗邻选择器：$(&quot;.father_div+div&quot;) 普通相邻选择器：$(&quot;.father_div~div&quot;) 基本筛选器 选取第一个div标签：$(&quot;div:first&quot;) 选取最后一个div标签：$(&quot;div:last&quot;) 选取索引为n的div标签：$(&quot;div:eq(n)&quot;) 选取索引小于n的div标签：$(&quot;div:lt(n)&quot;) 选取索引大于n的div标签：$(&quot;div:gt(n)&quot;) 选取索引为偶数的div标签：$(&quot;div:even&quot;) 选取索引为奇数的div标签：$(&quot;div:odd&quot;) 当前获取焦点的元素：$(&quot;:focus&quot;) 正在执行动画效果的元素：$(&quot;:animated&quot;) 属性选择器 获取所有的”id=’idA’”这个属性的标签：$(&quot;[id=&#39;idA&#39;]&quot;) 获取所有的”name=’img_list’”这个属性的标签：$(&quot;[name=&#39;img_list&#39;]&quot;) 选取所有的href属性的元素：$(&quot;[href]&quot;) 选取所有的target属性值等于”_blank”的 标签：$(&quot;a[target=&#39;_blank&#39;]&quot;) 选取所有的target属性值不等于”_blank”的 标签：$(&quot;a[target!=&#39;_blank&#39;]&quot;) 表单选择器 获取所有处于选中状态的复选框：$(&quot;input:checked&quot;) 获取所有的input,textarea,select和button元素：$(&quot;:input&quot;) 获取所有的单行文本框：$(&quot;:text&quot;) 获取所有的密码框：$(&quot;:password&quot;) 获取所有的单选按钮：$(&quot;radio&quot;) 获取所有的复选框：$(&quot;checkbox&quot;) 获取所有的提交按钮：$(&quot;submit&quot;) 获取所有的重置按钮：$(&quot;reset&quot;) 获取所有的button按钮：$(&quot;button&quot;) 获取所有的文件域：$(&quot;file&quot;) 过滤选择器 获取列表中索引为n的标签：$(&quot;li&quot;).eq(n) 获取列表中的第一个标签：$(&quot;li&quot;).first() 查询列表中是否有”test”这个类：$(&quot;ul li&quot;).hasclass(&quot;test&quot;)查找选择器 查找div标签中包含divA的所有子类标签：$(&quot;div&quot;).children(&quot;.divA&quot;) 查找div标签中包含divB的所有的后代标签：$(&quot;div&quot;).find(&quot;.divB&quot;) 获取classA这个类的下一个标签：$(&quot;.classA&quot;).next() 获取classA这个类的后面的所有标签：$(&quot;.classA&quot;).nextAll() 获取classA这个类后面,直到classB之间的所有标签：$(&quot;.classA&quot;).nextUntil(&quot;classB&quot;) 不含classB 获取classA类的前一个标签：$(&quot;.classA&quot;).prev() 获取classA类的所有的标签：$(&quot;.classA&quot;).prevAll() 获取classA类之前,直到classB(不含div2)的所有的标签：$(&quot;.classA&quot;).prevUntil(classB) 获取classA类的所有的同级标签 ：$(&quot;.classA&quot;).siblings() 获取classA类的父标签：$(&quot;.classA&quot;).parent() 获取classA类所有的父标签(包括父标签,父标签的父标签等,直到最上一级标签为止：$(&quot;.classA&quot;).parents() 获取classA类所有的父标签,直到指定的条件停止：$(&quot;.classA&quot;).parentsUntil() 以元素类型选择以$(&#39;HTML标签&#39;)构成，例如： 选择行： $(&#39;tr&#39;) 选择段落： $(&#39;div&#39;) 选择标题： $(&#39;h1&#39;) 选择输入框： $(&#39;input&#39;) 例子用一张表格举例，如下图： Html Markup 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;div id="table-zebra"&gt; &lt;table class="data" id="celebs"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Occupation&lt;/th&gt; &lt;th&gt;Approx.Location&lt;/th&gt; &lt;th&gt;Price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbady&gt; &lt;tr&gt; &lt;td&gt;203A&lt;/td&gt; &lt;td&gt;Johny&lt;/td&gt; &lt;td&gt;Front-man&lt;/td&gt; &lt;td&gt;Los Angeles&lt;/td&gt; &lt;td&gt;$39.95&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;141B&lt;/td&gt; &lt;td&gt;Beau&lt;/td&gt; &lt;td&gt;Singer&lt;/td&gt; &lt;td&gt;New York&lt;/td&gt; &lt;td&gt;$39.95&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2031&lt;/td&gt; &lt;td&gt;Mo Fat&lt;/td&gt; &lt;td&gt;Producer&lt;/td&gt; &lt;td&gt;New York&lt;/td&gt; &lt;td&gt;$19.95&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;007F&lt;/td&gt; &lt;td&gt;Kellie Kelly&lt;/td&gt; &lt;td&gt;Singer&lt;/td&gt; &lt;td&gt;Omaha&lt;/td&gt; &lt;td&gt;$11.95&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;8A05&lt;/td&gt; &lt;td&gt;Darth&lt;/td&gt; &lt;td&gt;DJ&lt;/td&gt; &lt;td&gt;London&lt;/td&gt; &lt;td&gt;$19.95&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;6636&lt;/td&gt; &lt;td&gt;Glendatronix&lt;/td&gt; &lt;td&gt;Keytarist&lt;/td&gt; &lt;td&gt;London&lt;/td&gt; &lt;td&gt;$39.95&lt;/td&gt; &lt;/tr&gt; &lt;/tbady&gt; &lt;/table&gt;&lt;/div&gt; 以id和class选择假设有多个表格，而只需要选择这整个表格，可以根据id或class来选择: 按id选择，在#号后加元素的id，并将其作为字符串传入jQuery函数： $(&#39;#celebs&#39;) 按class选择，在句点(.)后加元素的类名(class)，并将其作为字符串传入jQuery函数： $(&#39;.data&#39;) 缩写选择范围可以根据层级关系，进一步选择元素。祖先和后代之间留一空格即可。 假设想要选择到这个表格的行，可以这样写$(&#39;#celebs tr&#39;) 使用筛选器加到要筛选的项目上，以冒号(:)进行定义，其后接筛选器的名称。 再进一步，假设我们想选择这个表格的偶数行，$(&#39;#celebs tr:even&#39;) even: 保留选择器中索引号为偶数的元素，删除其余元素 修饰添加和删除样式、类及其他 处理CSS读取CSS访问CSS，读取classA的字体大小：$(&#39;.classA&#39;).css(&#39;font-size) 设置CSS修改CSS，设置classA的字体大小：$(&#39;.classA&#39;).css(&#39;font-size&#39;,&#39;12px&#39;) 移除CSS类移除CSS，移除div的oldCss类：$(&#39;div&#39;).removeClass(&#39;oldCss&#39;) 添加CSS类添加CSS，添加div的newCss类；$(&#39;div&#39;).addClass(&#39;newCss&#39;) 切换类切换CSS，切换div的toggleCss类；$(&#39;div&#39;).toggleClass(&#39;toggleCss&#39;)添加或者移除CSS类：如果CSS类已经存在，它将被移除；相反，如果CSS类不存在，它将被加上 例子在将上一节提到的表格改造成斑马条纹的，形如： 逐条设置CSS1234// 将表格中的偶数行的背景颜色设置为#ddd$('#celebs tbody tr:even').css('background-color','#ddd');// 将表格中的偶数行的字体颜色设置为#666$('#celebs tbody tr:even').css('color','#666'); 使用对象字面量（object literal）来设置多个属性如果需要设置的属性很多，一条条代码来写显然非常麻烦和繁琐。jQuery提供了一种一颗同时设置多个属性的方法，即使用对象字面量。对象字面量封装在尖括号内，里面的每个键和值之间用冒号分隔，每对键值之间用逗号分隔，例如： 123456$('celebs tbody tr:even').css(&#123; 'background-color':'#ddd', 'color':'#666', 'font-size':'11pt', 'line-height':'2.5em'&#125;); 添加和删除类通常并不推荐在HTML/CSS使用内联样式，为了保持代码整洁、便于维护、通常会使用外联样式。这一点在使用就jQuery的时候也同样适用。在这一节，我们将样式放在样式表内，通过添加和删除类来达到同样的效果。 首先在HTML内添加一个CSS文件的链接： Html Markup 12345&lt;head&gt; ... &lt;title&gt;zebra table&lt;/title&gt; &lt;link rel="stylesheet" href="zebra.css"&gt;&lt;/head&gt; 然后将新规则添加到新的CSS文件中： zebra.css 1234.zebra&#123; background-color:#666; color: #ddd;&#125; 最后，回到JavaScript文件中，添加CSS类： 1$("#table-zebra table tbody tr:even").addClass('zebra'); 当然要删除的话也特别简单： 1$("#table-zebra table tbody tr:even").removeClass('zebra'); 增强事件事件处理器故名思意，用于处理事件。事件是在网页发生的操作，当事件发生时，我们称此为触发了事件，当我们编写代码处理事件时，我们称此为捕获了事件。 浏览器事件 文档加载 绑定事件处理器 事件对象 键盘事件 鼠标事件具体的说明请参考：Jquery中文文档-事件 显示、隐藏和切换元素 显示：hide() 隐藏：hide() 切换：toggle() 添加和删除元素 添加新元素：实际上，放在jQuery函数内的任何有效的HTML字符串都会被创建，例如创建一个锻炼元素：$(&#39;&lt;p&gt;A new paragraph!&lt;/p&gt;&#39;) 插入元素：将元素创建后还需要将它放入页面中。 insertAfter(&#39;#idA&#39;)将元素插入在id为idA的元素后面。 insertBefore(&#39;#idB&#39;)将元素插入在id为idB的元素前面。 prependTo(&#39;idC&#39;)将元素作为id为idC的子元素插入到最前面。 appendTo(&#39;idD&#39;)将元素作为id为idD的子元素插入到最后面。 删除元素：remove() 修改内容： 修改为HTML:html() 修改为纯文本：text() 例子要达成的效果如图一：首先，我们创建一个结构如图的html文件，并且引入jQuery文件和我们自定义的js文件。然后我们添加一个按钮：Js File123$(document).ready(function () &#123; $('&lt;input type="button" value="hide" id="hideButton"&gt;').insertAfter('#statement');&#125;); 然后我们为这个按钮添加click事件，让其点击之后就将免责声明隐藏： Js File 123$('#hideButton').click(function () &#123; $("#statement").hide();&#125;); 文件隐藏后再点击按钮就显示免责声明： Js File 12345678910111213$(document).ready(function () &#123; $('&lt;input type="button" value="Show" id="toggleButton"&gt;').insertAfter('#statement'); $('#toggleButton').click(function () &#123; if ($('#statement').is(':visible')) &#123; $('#statement').hide(); $(this).val('Show'); &#125;else&#123; $('#statement').show(); $(this).val('Hide'); &#125; &#125;);&#125;); is操作接受传递给jQuery函数的任何选择器，检查它们与调用元素是否匹配 this引用了jQuery函数选择的元素 现在效果如图二： 但实际上，jQuery有切换的函数： 1234567$(document).ready(function () &#123; $('&lt;input type="button" value="Show" id="toggleButton"&gt;').insertAfter('#statement'); $('#toggleButton').click(function () &#123; $('#statement').toggle(); &#125;);&#125;); 添加一些特效(之后的文章会详细说明) 123456789101112$(document).ready(function () &#123; $('&lt;input type="button" value="Toggle" id="toggleButton" &gt;').insertAfter('#statement'); $('#toggleButton').click(function () &#123; if ($('#statement').is(':visible')) &#123; $('#statement').fadeOut(); $(this).val('Hide'); &#125; else &#123; $('#statement').fadeIn(); $(this).val('Show'); &#125; &#125;);&#125;); 参考资料：《jQuery从菜鸟到忍者》]]></content>
      <categories>
        <category>前端</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Less快速入门]]></title>
    <url>%2F2017%2F09%2F19%2Fless%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。 在客户端使用Less首先引入.less文件。要设置rel属性值为“stylesheet/less”： 1&lt;link rel="stylesheet/less" type="text/css" href="styles.less"&gt; 在这里下载Less 之后,然后在\中引入： 1&lt;script src="less.js" type="text/javascript"&gt;&lt;/script&gt; 注意：你的less样式文件一定要在引入less.js前先引入。 注释less的注释有两种，//和/ / Less Code 123456// 单行注释，不编译/* 多行注释，编译 多行注释，编译 多行注释，编译*/ Compiled Css Code: 12345/* 多行注释，编译 多行注释，编译 多行注释，编译*/ 变量以@开头 例如：@test_width:100px; Less Code1234@text_width:100px;.text&#123; width: @text_width;&#125; Compiled Css Code:123.text &#123; width: 100px;&#125; 混合一个类可以当做另一个元素的属生值，并可以接受自己的参数。 可以在一个classA中引入另一个classB，从而实现classB继承classA的所有属性，可以带参数。经常使用在封装兼容不同浏览器的情况下。 无参混合Less Code1234567891011.classA&#123; border: 10px solid red; border-radius: 5px; -webkit-border-radius:5px; -moz-border-radius:5px; &#125;.classB&#123; .classA; width: 50px; height: 50px;&#125; Compiled Css Code:1234567891011121314.classA &#123; border: 10px solid red; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px;&#125;.classB &#123; border: 10px solid red; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; width: 50px; height: 50px;&#125; 带参数混合(不带默认值)Less Code1234567891011.classA(@radius)&#123; border: 10px solid red; border-radius: @radius; -webkit-border-radius: @radius; -moz-border-radius: @radius; &#125;.classB&#123; .classA(10px); width: 50px; height: 50px;&#125; Compiled Css Code:12345678.classB &#123; border: 10px solid red; border-radius: 10px; -webkit-border-radius: 10px; -moz-border-radius: 10px; width: 50px; height: 50px;&#125; 带参数混合(带默认值)Less Code1234567891011.classA(@radius:5px)&#123; border: 10px solid red; border-radius: @radius; -webkit-border-radius: @radius; -moz-border-radius: @radius; &#125;.classB&#123; .classA(); width: 50px; height: 50px;&#125; Compiled Css Code:12345678.classB &#123; border: 10px solid red; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; width: 50px; height: 50px;&#125; @arguments变量在Mixins中使用这个参数的时候，它表示所有的变量。 Less Code: 12345678.box(@x:0,@y:0,@blur:1px,@color:gray)&#123; -moz-box-shadow:@arguments; -webkit-box-shadow:@arguments; box-shadow: @arguments; &#125;#main&#123; .box(5px,5px,6px,#662500);&#125; Compiled Css Code: 12345#main &#123; -moz-box-shadow: 5px 5px 6px #662500; -webkit-box-shadow: 5px 5px 6px #662500; box-shadow: 5px 5px 6px #662500;&#125; 匹配.name(条件一，参数){}.name(条件二，参数){}.name(@_,参数){}调用：.name(条件值，参数值); 假设需要做一个三角形的图标，三角形可能朝不同的方向，可以这样写： Less Code 1234567891011121314151617181920212223242526272829//@_意思是与top,bottom,left,right都匹配.triangle(@_,@w:5px,@c:gray)&#123; width: 0px; height: 0px; overflow: hidden;&#125; .triangle(top,@w:5px,@c:gray)&#123; border-width: @w; border-color: transparent transparen @c transparent; border-style: dashed dashed solid;&#125;.triangle(bottom,@w:5px,@c:gray)&#123; border-width: @w; border-color: @c transparen transparent transparent; border-style: solid dashed dashed;&#125;.triangle(left,@w:5px,@c:gray)&#123; border-width: @w; border-color: transparen @c transparent transparent; border-style: dashed solid dashed dashed;&#125;.triangle(right,@w:5px,@c:gray)&#123; border-width: @w; border-color: transparen transparent transparent @c; border-style: dashed dashed dashed solid;&#125;.sanjiao&#123; .triangle(top,100,green);&#125; Compiled Css Code: 12345678.sanjiao &#123; width: 0px; height: 0px; overflow: hidden; border-width: 100; border-color: transparent transparen #008000 transparent; border-style: dashed dashed solid;&#125; 这样就可以在需要使用不同方向的三角时，直接通过匹配实现。 运算任何数字、颜色、变量都可以参与运算，运算被包裹在括号中。 颜色的运算不常用到，更多的是数字和变量的运算。 运算中没有强制性规定一定要带单位，运算中只要有一个带单位的即可,如果单位不同，以先出现的单位为准 Less Code 1234567891011121314151617@width_a: 500px;@width_b: 50px;.text_01 &#123; width: @width_a + 20;&#125;.text_02 &#123; width: @width_a + 20rem;&#125;.text_03 &#123; width: 20rem + @width_a;&#125;.text_04 &#123; width: @width_a - @width_b;&#125; Compiled Css Code: 123456789101112.text_01 &#123; width: 520px;&#125;.text_02 &#123; width: 520px;&#125;.text_03 &#123; width: 520rem;&#125;.text_04 &#123; width: 450px;&#125; 嵌套Html Markup: 1234&lt;div id="box"&gt; &lt;p&gt;hello &lt;a href="http://zhyat.cn"&gt;zhyat&lt;/a&gt;&lt;/p&gt; &lt;span&gt;一些学习笔记&lt;/span&gt; &lt;/div&gt; Less Code: 123456789101112131415161718#box&#123; display: inline; float: left; p&#123; font-size: 15px; a&#123; text-decoration: none; color: gray; &amp;:hover&#123; color: blue; &#125; &#125; &#125; span&#123; font-size: 12px; color:pink; &#125;&#125; Compiled Css Code: 123456789101112131415161718#box &#123; display: inline; float: left;&#125;#box p &#123; font-size: 15px;&#125;#box p a &#123; text-decoration: none; color: gray;&#125;#box p a:hover &#123; color: blue;&#125;#box span &#123; font-size: 12px; color: pink;&#125; 根据DOM树形结构去书写代码，从而减少选择器的层级关系，使得代码更简洁。 需要注意的是在操作伪代码的时候，需要再前面加&amp;。有&amp;的时候解析为同一元素或此元素的伪类，没有&amp;的时候解析为此元素的后代元素 Less Code 1234567891011121314a&#123; &amp;:hover&#123; color: blanchedalmond; &#125; &amp;&#123; font-size: 15px; &#125; :visited&#123; color: burlywood; &#125; .ml&#123; font-weight: 40; &#125;&#125; Comoiled Css Code 123456789101112a &#123; font-size: 15px;&#125;a:hover &#123; color: blanchedalmond;&#125;a :visited &#123; color: burlywood;&#125;a .ml &#123; font-weight: 40;&#125; color函数颜色定义函数Less Code 12345678910111213141516@color1:rgb(255,255,255); //转化为#ffffff param1:红色通道 param2:绿色通道 param3:蓝色通道 三个参数均是包含介于0 - 255之间的整数或介于0 - 100%之间的百分比。@color2:rgba(155,155,155,0.2); //rgba(155, 155, 155, 0.2) 同上，param4是alpha通道，包含0到1之间的数字或0到100%之间的百分比。@color4:hsl(22,100%,20%); //转化为#662500,param1:度数（0~360，整数） param2:饱和度(0~1或0~100%) param3:亮度(0~1或0~100%)@color5:hsla(22,100%,20%,0.4); //转化为rgba(102, 37, 0, 0.4)，同上，param4是alpha通道，包含0到1之间的数字或0到100%之间的百分比。@color6:hsv(55,0.7,0.5); //转化为#807826,param1:度数（0~360，整数） param2:饱和度(0~1或0~100%) param3:value(0~1或0~100%)@color7:hsva(125,179,18,0.6); //转化为rgba(0, 255, 0, 0.6),同上，param4是alpha通道，包含0到1之间的数字或0到100%之间的百分比。.box&#123; width: 50px; height: 50px; border-width: 2px; border-style: solid; border-color: @color1 @color2 @color4 @color5; background-color: @color6; color: @color7;&#125; Comoiled Css Code 123456789.box &#123; width: 50px; height: 50px; border-width: 2px; border-style: solid; border-color: #ffffff rgba(155, 155, 155, 0.2) #662500 rgba(102, 37, 0, 0.4); background-color: #807826; color: rgba(0, 255, 0, 0.6);&#125; 颜色通道函数 序号 函数 描述 例子 1 hue 在HSL颜色中提取颜色的色调 hue( hsl(22,100%,20%);``` Comoiled Css Code ``` background: 22;``` |12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576| 2 | saturation | 在HSL颜色中，提取彩色对象的饱和通道。 | ```background: saturation( hsl(22,100%,20%);```Comoiled Css Code ``` background: 100%;``` || 3 | lightness | 在HSL颜色空间中，从颜色对象提取亮度通道。 | ```background: lightness( hsl(22,100%,20%);```Comoiled Css Code ``` background: 20%;``` || 4 | hsvhue | 在HSV色彩空间中，提取色彩对象的色调通道。 | ``` background: hsvhue(hsv(55,0.7,0.5));``` Comoiled Css Code ``` background: 55;``` || 5 | hsvsaturation | 在HSL颜色空间中，提取彩色对象的饱和通道。 | ``` background: hsvsaturation(hsv(55,0.7,0.5));``` Comoiled Css Code ``` background: 70%;``` || 6 | hsvvalue | 在HSL颜色空间中，提取颜色对象的值通道。 | ``` background: hsvvalue(hsv(55,0.7,0.5));``` Comoiled Css Code ``` background: 50%;``` || 7 | red | 提取彩色对象的红色通道。 | ``` background: red(rgba(155,154,153,0.2));``` Comoiled Css Code ``` background: 155;``` || 8 | green | 提取彩色对象的绿色通道。 | ``` background: green(rgba(155,154,153,0.2));``` Comoiled Css Code ``` background: 154;``` || 9 | blue | 提取彩色对象的蓝色通道。 | ``` background: blue(rgba(155,154,153,0.2));``` Comoiled Css Code ``` background: 153;``` || 10 | alpha | 提取颜色对象的alpha通道。 | ``` background: alpha(rgba(155,154,153,0.2));``` Comoiled Css Code ``` background: 0.2;``` || 11 | luma | 计算颜色对象的亮度值。 | ``` background: luma(rgba(155,154,153,0.2));``` Comoiled Css Code ``` background: 6.47593448%;``` || 12 | luminance | 在没有伽马校正的情况下计算亮度值。 | ``` background: luminance(rgba(155,154,153,0.2));``` Comoiled Css Code ``` background: 12.08944314%;``` |##### 颜色操作以不同的方式改变和操作颜色，形如function(param1,param2);param1是颜色对象param2可以是| 序号 | 函数 | 描述 || :--: | :--------: | :------------------: || 1 | saturate | 改变元素中颜色的强度或饱和度。 || 2 | desaturate | 降低了元素中颜色的强度或饱和度 || 3 | lighten | 增加了元素中颜色的亮度 || 4 | darken | 改变元素中颜色的强度或饱和度 || 5 | fadein | 增加了所选元素的不透明度 || 6 | fadeout | 减少所选元素的不透明度 || 7 | fade | 用于设置所选元素的颜色的透明度 || 8 | spin | 用于旋转所选元素的颜色的角度 || 9 | mix | 将两种颜色与不透明度混合 || 10 | tint | 将颜色与白色混合，同时减少颜色的比例 || 11 | shade | 将颜色与黑色混合，因为您减少了颜色的比例 || 12 | greyscale | 从所选元素中的颜色中丢弃饱和度 || 13 | contrast | 设置元素中颜色的对比度 |##### 颜色混合函数| 序号 | 函数 | 描述 || :--: | :--------: | :--------------------------------: || 1 | multiply | 将两种颜色相乘，并返回结果颜色 || 2 | screen | 需要两种颜色，并返回更明亮的颜色。 与multiply函数相反 || 3 | overlay | 它通过组合乘法和屏幕的效果来生成结果 || 4 | softlight | 工作方式类似于覆盖，但它仅使用颜色的一部分，其中柔和突出显示其他颜色 || 5 | hardlight | 工作方式类似于覆盖 ，但颜色的作用相反 || 6 | difference | 从第一输入颜色中减去第二输入颜色 || 7 | exclusion | 工作原理类似于difference，但对比度较低 || 8 | average | 计算每个通道(RGB)基础上的两种输入颜色的平均值 || 9 | negation | 与opposite函数相反，其从第二颜色中减去第一颜色 |#### 命名空间在为了更好的组织CSS或者为了更好的封装，将一些变量和混合模块打包起来。在使用的时候，就需要把有关的一部分取出来。*Less Code*```less#bundle &#123; .button () &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; &#125; .citation &#123; &#125; &#125;#header a&#123; color: orange; #bundle &gt; .button;&#125; Comoiled Css Code 123456789#header a &#123; color: orange; display: block; border: 1px solid black; background-color: grey;&#125;#header a:hover &#123; background-color: #ffffff;&#125; 作用域less的作用域和别的编程语言非常相似，变量同样也有作用范围，首先会先从本地查找，如果没有再从父级的作用域查找。其实就是就近原则，元素先查找本身有没有这个变量，如果有，就取本身的变量，如果没有，就从父级元素的作用域查找，以此类推，直至找到相应的变量。 Less Code 12345678@var:green;#main&#123; @var:white; #box&#123; @var:red; color: @var; &#125;&#125; Comoiled Css Code 123#main #box &#123; color: #ff0000; //red&#125; !importing提升优先级,但是和css一样，不推荐使用，多用于调试。会为所有的混合所带来的样式，添加上!importing Less Code 1234567#box &#123; border: 5px solid red; border-radius: 3px;&#125;#main&#123; #box !important;&#125; Comoiled Css Code 12345678#box &#123; border: 5px solid red; border-radius: 3px;&#125;#main &#123; border: 5px solid red !important; border-radius: 3px !important;&#125; importing引入.less,.less后缀可不带 12@import "lib.less";@import "lib"; 如果你想导入一个CSS文件而且不想LESS对它进行处理，只需要使用.css后缀就可以: 1@import "lib.css"; 避免编译将需要避免编译的字符串用“”包含，并在“前加上~，如： 123.class &#123; filter: ~"ms:alwaysHasItsOwnSyntax.For.Stuff()";&#125; 参考资料： Less 一种动态样式语言 大漠的博客 CSS-LESS imooc–less即学即用]]></content>
      <categories>
        <category>前端</category>
        <category>Less</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP 5.0 响应]]></title>
    <url>%2F2017%2F09%2F14%2FThinkPHP5.0%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[ThinkPHP5.0响应 响应对象 用于动态响应客户端请求 控制发送给用户的信息 动态生成响应 常用于输出数据给客户端或浏览器 手动输出 输出类型 快捷方法 例子 渲染模板输出 view $this-&gt;fetch(‘index/index1’); JSON输出 json json($data,200); JSONP输出 jsonp jsonp($data,200); XML输出 xml xml($data); 页面重定向 redirect $this-&gt;redirect(‘http://xxx.com&#39;)； 页面跳转12$this-&gt;success('正确的页面跳转'，'success')A;//success-控制器$this-&gt;error('错误的页面跳转','error'); 页面重定向1$this-&gt;redirect('http://xxx.com')；]]></content>
      <categories>
        <category>PHP</category>
        <category>thinkPHP 5.0</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP 5.0 请求]]></title>
    <url>%2F2017%2F09%2F13%2FThinkPHP5.0%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[ThinkPHP5.0请求 请求对象： Request对象的作用是与客户端交互，收集客户端的form、URL、Cookie等。 Request对象是从客户端向服务器发出请求，包括用户提交的信息以及客户端的一些信息。客户端可通过HTML表单或在网页地址后面提供参数的方法提交数据，然后通过Request对象的相关方法来获取这些数据。Request的各种方法主要用来处理客户端浏览器提交的请求中的各项参数和选项。 动态绑定属性：1Request::instance()-&gt;bind('user',$user); 获取URL:1request()-&gt;url(); //函数助手 请求变量信息：123Request::instance()-&gt;param('user'); //可传参数，否则获取所有参数$request-&gt;param('user','Tom','strtolower'); //支持变量的过滤和默认值input('user'); //函数助手的写法，作用相同 get post cookie file1234$request-&gt;get(); //get$request-&gt;post(); //post$request-&gt;cookie(); //cookie$request-&gt;file(); //上传文件 其他参数12345678910$request-&gt;method(); // 请求方法$request-&gt;ip(); // 访问IP$request-&gt;isAjax(); // 是否Ajax请求$request-&gt;domain(); // 当前域名$request-&gt;baseFile(); // 当前入口文件$request-&gt;url(ture); // 包含域名的完整url地址，有true完整的url，没有true不含域名$request-&gt;query(); // url地址的参数信息$request-&gt;baseUrl(); // 当前的url地址，不含QUERY_STRING$request-&gt;pathinfo(); // url地址中的pathinfo信息$request-&gt;ext(); // url地址中的后缀信息 当前模块/控制器/操作信息123$request-&gt;module(); // 当前模块$request-&gt;controller(); // 当前控制器$request-&gt;action(); // 当前操作信息]]></content>
      <categories>
        <category>PHP</category>
        <category>thinkPHP 5.0</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP 5.0 数据库]]></title>
    <url>%2F2017%2F05%2F19%2FThinkPHP5.0%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[ThinkPHP5.0数据库 一.数据库配置在appliation/database.php中配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php// +----------------------------------------------------------------------// | ThinkPHP [ WE CAN DO IT JUST THINK ]// +----------------------------------------------------------------------// | Copyright (c) 2006~2016 http://thinkphp.cn All rights reserved.// +----------------------------------------------------------------------// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +----------------------------------------------------------------------// | Author: liu21st &lt;liu21st@gmail.com&gt;// +----------------------------------------------------------------------return [ // 数据库类型 'type' =&gt; 'mysql', // 服务器地址 'hostname' =&gt; '127.0.0.1', // 数据库名 'database' =&gt; '', // 用户名 'username' =&gt; 'root', // 密码 'password' =&gt; '', // 端口 'hostport' =&gt; '', // 连接dsn 'dsn' =&gt; '', // 数据库连接参数 'params' =&gt; [], // 数据库编码默认采用utf8 'charset' =&gt; 'utf8', // 数据库表前缀 'prefix' =&gt; '', // 数据库调试模式 'debug' =&gt; true, // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器) 'deploy' =&gt; 0, // 数据库读写是否分离 主从式有效 'rw_separate' =&gt; false, // 读写分离后 主服务器数量 'master_num' =&gt; 1, // 指定从服务器序号 'slave_no' =&gt; '', // 是否严格检查字段是否存在 'fields_strict' =&gt; true, // 数据集返回类型 'resultset_type' =&gt; 'array', // 自动写入时间戳字段 'auto_timestamp' =&gt; false, // 时间字段取出后的默认时间格式 'datetime_format' =&gt; 'Y-m-d H:i:s', // 是否需要进行SQL性能分析 'sql_explain' =&gt; false,]; 二.原生sql语句12345678//插入记录$result = Db::execute('insert into tp_data (id,name) values (1,"zhayt")');//更新记录$result = Db::execute('update tp_data set name = "Zhang" where id = 1');//查询数据$result = Db::query('select * from tp_data where id=1');//删除数据$result = Db::execute('delete from tp_data where id=1'); 三.参数绑定、命名占位符绑定1.参数绑定123//问号为占位符，后面的参数一一对应替代$result = Db::execute('insert into tp_data (id,name) values (?,?),[1,'zhyat']');//等价于 $result = Db::execute('insert into tp_data (id,name) values (1,"zhyat")'); 2.命名占位符绑定1Db:execute('insert into tp_data (id,name) values (:id, :name)',['id'=&gt;1,'name'=&gt;'zhyat']); 四.多个数据库切换查询操作1.在application/config.php配置12345678910111213141516171819202122232425262728293031323334353637383940'db1' =&gt; [ // 数据库类型 'type' =&gt; 'mysql', // 服务器地址 'hostname' =&gt; '127.0.0.1', // 数据库名 'database' =&gt; 'tp_db1', // 用户名 'username' =&gt; 'root', // 密码 'password' =&gt; '', // 端口 'hostport' =&gt; '', // 数据库连接参数 'params' =&gt; [], // 数据库编码默认采用utf8 'charset' =&gt; 'utf8', // 数据库表前缀 'prefix' =&gt; 'tp_', ],'db2' =&gt; [ // 数据库类型 'type' =&gt; 'mysql', // 服务器地址 'hostname' =&gt; '127.0.0.1', // 数据库名 'database' =&gt; 'tp_db2', // 用户名 'username' =&gt; 'root', // 密码 'password' =&gt; '', // 端口 'hostport' =&gt; '', // 数据库连接参数 'params' =&gt; [], // 数据库编码默认采用utf8 'charset' =&gt; 'utf8', // 数据库表前缀 'prefix' =&gt; 'tp_', ], 2.使用方法12$result = Db::connect(db1)-&gt;query('select * from tp_data where id=1');$result = Db::connect(db2)-&gt;query('select * from tp_data where id=1'); 五.查询构造器ThinkPHP5.0中提供了查询构造器，基于PDO实现，使用了PDO参数绑定，传入的参数不需要额外的转义特殊字符 12345678910111213141516//插入记录Db::table('tp_data')-&gt;insert(['id'=&gt;1,'name'=&gt;'zhyat']);//等效上一条，会自动去config.php寻找前缀，更推荐使用这种Db::name('data')-&gt;insert(['id'=&gt;1,'name'=&gt;'zhyat']);//更新记录Db::table('tp_data') -&gt;where('id',1) -&gt;updata(['name'=&gt;zhyat]);//查询数据$list=Db::table('tp_data') -&gt;where('id',1) -&gt;select();//删除数据Db::table('tp_data') -&gt;where('id',1) -&gt;delete(); 六.DB链式操作12345678//查询方法和CURD都可以使用连贯操作//链式操作的结果不会带入后面的其它查询//顺序可以变动Db::table('think_user') -&gt;where('status',1) -&gt;order('create_time') -&gt;limit(10) -&gt;select();//select方法必须放到最后,因为其不是链式操作方法 七.事物支持1.什么是事物几个操作同步进行，要不全部成功，要不就全部撤销，这几个操作组合称为事务 2.要在Mysql数据库中设置表类型为InnoDB3.自动：1234Db:transaction(function()&#123; Db::name(data)-&gt;delete(1); Db::name(data)-&gt;insert(['id'=&gt;2,'name'=&gt;'zhyat']);); 4.手动：1234567891011//启动事务Db::startTrans();try&#123; Db::table('tp_data')-&gt;detele(1); Db::name(data)-&gt;insert(['id'=&gt;2,'name'=&gt;'zhyat']); //提交事务 Db:commit();&#125; catch(\Exception $e)&#123; //回滚事务 Db::rollback(); &#125;]]></content>
      <categories>
        <category>PHP</category>
        <category>thinkPHP 5.0</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Three.js入门指南》总结（1~3章）]]></title>
    <url>%2F2017%2F03%2F04%2F%E3%80%8AThree.js%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%AC%AC1-3%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[Three.js是一个3D JavaScript库。 Three.js封装了底层的图形接口，使得程序员能够在无需掌握繁冗的图形学知识的情况下，也能用简单的代码实现三维场景的渲染。 概述一.配置环境： 在three.js下载。其中three.js没有经过代码压缩，适合调试，three.js经过了代码压缩，文件较小，适合发布最终版的时候使用。 在使用three.js之前，需要在html中引用：1&lt;script type="text/javascript" src="three.js"&gt;&lt;/script&gt; 二.一个典型的Three.js程序至少要包括渲染器（Renderer）、场景（Scene）、照相机（Canmer）,以及你在场景中创建的物体 将渲染器和Canvas绑定。 在程序最开始的时候将场景进行实例化 定义照相机，并将其添加进场景 创建物体，添加进场景 进行渲染 123456789101112131415161718192021222324function init() &#123; // render var renderer = new THREE.WebGLRenderer(&#123; canvas: document.getElementById('mainCanvas') &#125;); renderer.setClearColor(0x000000);//将背景色设为黑色，用于清除画面的颜色 //scene var scene = new THREE.Scene(); //camera var camera = new THREE.PerspectiveCamera(45, 4 / 3, 1, 1000); camera.position.set(0, 0, 5); scene.add(camera); // a cube in the scene var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 2, 3), new THREE.MeshBasicMaterial(&#123; color: 0xff0000 &#125;) ); scene.add(cube); renderer.render(scene, camera);&#125; 照相机一.什么是照相机在图形学中指定三维空间到二维屏幕的投影方式 针对投影方式的不同，照相机又分为正交投影照相机与透视投影照相机 二.透视投影vs透视投影 透视投影 正交投影 特点 近大远下，接近人的观察效果 三维空间平行的线，三维空间也平行，投影不改变物体比例 适用场合 制图、建模软件等 其他大多数应用 构造函数 THREE.PerspectiveCamera(fov, aspect, near, far) THREE.OrthographicCamera(left, right, top, bottom, near, far) 根据应用特性来选择一个效果更佳的照相机 三.正交投影相机为了保持照相机的横竖比例，需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致。 ear与far都是指到照相机位置在深度平面的位置，而照相机不应该拍摄到其后方的物体，因此这两个值应该均为正值。为了保证场景中的物体不会因为太近或太远而被照相机忽略，一般near的值设置得较小，far的值设置得较大，具体值视场景中物体的位置等决定。 1234567891011121314151617181920212223242526function init() &#123; var renderer = new THREE.WebGLRenderer(&#123; canvas: document.getElementById('mainCanvas') &#125;); renderer.setClearColor(0x000000); var scene = new THREE.Scene(); // camera // canvas size is 400x300 var camera = new THREE.OrthographicCamera(-2, 2, 1.5, -1.5, 1, 10); camera.position.set(0, 0, 5); //camera.lookAt(new THREE.Vector3(0, 0, 0)); scene.add(camera); // a cube in the scene var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), new THREE.MeshBasicMaterial(&#123; color: 0xff0000, wireframe: true &#125;) ); scene.add(cube); // render renderer.render(scene, camera);&#125; 四.透视投影相机fov是视景体竖直方向上的张角（是角度制而非弧度制）。 aspect等于width / height，是照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。 near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near 改变fov并不会引起画面横竖比例的变化，而改变aspect则会改变横竖比例。 12345678910111213141516171819202122232425function init() &#123; var renderer = new THREE.WebGLRenderer(&#123; canvas: document.getElementById('mainCanvas') &#125;); renderer.setClearColor(0x000000); var scene = new THREE.Scene(); // camera // canvas size is 400x300 var camera = new THREE.PerspectiveCamera(60, 400 / 300, 1, 10); camera.position.set(0, 0, 5); scene.add(camera); // a cube in the scene var cube = new THREE.Mesh(new THREE.CubeGeometry(1, 1, 1), new THREE.MeshBasicMaterial(&#123; color: 0xff0000, wireframe: true &#125;) ); scene.add(cube); // render renderer.render(scene, camera); &#125; 几何形状一.基本几何形状 几何体形状 构造函数 参数 立方体 THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) X方向上的长度；Y方向上的长度；Z方向的长度；X方向上的分段；Y方向上的分段；Z方向上的分段 平面 THREE.PlaneGeometry(width, height, widthSegments, heightSegments) X方向上的长度；Y方向的长度；X方向上的分段；Y方向上的分段 球体 THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength) 半径；经度上的切片数；纬度上的切片数；经度开始的弧度；经度跨过的弧度；纬度开始的弧度；纬度跨过的弧度 圆形 THREE.CircleGeometry(radius, segments, thetaStart, thetaLength) 半径；切片数；开始的弧度；跨过的弧度 圆柱体 THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded) 顶面半径；底面半径；半径分段；高度分段；是否没有顶面和底面 正四面体 THREE.TetrahedronGeometry(radius, detail) 半径；细节层次的层数 正八面体 THREE.OctahedronGeometry(radius, detail) 同上 正十二面体 THREE.IcosahedronGeometry(radius, detail) 同上 圆环面 THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) 圆环半径；管道半径；分段；分段；圆环的弧度 圆环结 THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale) 圆环半径；管道半径；分段；分段；圆环的弧度；样式参数；样式参数；z轴上的缩放 二.文字形状 下载使用在github下载xxx.json文件，放入目录下，用以下方法加载： 123456789101112var loader = new THREE.FontLoader();loader.load('../lib/xxx.json', function(font) &#123; var mesh = new THREE.Mesh(new THREE.TextGeometry('Hello', &#123; font: font, size: 1, height: 1 &#125;), material); scene.add(mesh); // render renderer.render(scene, camera);&#125;); 参数介绍构造函数为THREE.TextGeometry(text, parameters)； text是文字字符串，parameters是以下参数组成的对象： size：字号大小，一般为大写字母的高度 height：文字的厚度 curveSegments：弧线分段数，使得文字的曲线更加光滑 font：字体，默认是’helvetiker’，需对应引用的字体文件 weight：值为’normal’或’bold’，表示是否加粗 style：值为’normal’或’italics’，表示是否斜体 bevelEnabled：布尔值，是否使用倒角，意为在边缘处斜切 bevelThickness：倒角厚度 bevelSize：倒角宽度 自定义形状 需手动指定每个顶点的位置，以及顶点连接情况。 自定义形状使用的是Geometry类，它是其他如CubeGeometry、SphereGeometry等几何形状的父类，其构造函数是：THREE.Geometry() 123graph LRA[初始几何化形状]--&gt;B[设置顶点位置]B--&gt;C[设置顶点连接情况] Three.js入门指南]]></content>
      <categories>
        <category>前端</category>
        <category>Three.js</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
